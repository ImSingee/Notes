title:: Readwise/Highlights/系统设计题面试八股文背诵版 - 墨天轮 (65)
author:: [[modb.pro]]
full-title:: 系统设计题面试八股文背诵版 - 墨天轮
category:: #articles
url:: https://www.modb.pro/db/135068

- 有的面试官会问，如何让ID可以粗略的按照时间排序？上面的这种格式的ID，含有时间戳，且在高位，恰好满足要求。如果面试官又问，如何保证ID严格有序呢？在分布式这个场景下，是做不到的，要想高性能，只能做到粗略有序，无法保证严格有序。 #Highlight #[[2022-08-18]]
- 短网址的长度当前互联网上的网页总数大概是 45亿(参考 http://www.worldwidewebsize.com)，45亿超过了 2^{32}=4294967296232=4294967296，但远远小于64位整数的上限值，那么用一个64位整数足够了。微博的短网址服务用的是长度为7的字符串，这个字符串可以看做是62进制的数，那么最大能表示{62}^7=3521614606208627=3521614606208个网址，远远大于45亿。所以长度为7就足够了 #Highlight #[[2022-08-18]]
- 一个长网址，对应一个短网址，还是可以对应多个短网址？这也是个重大选择问题一般而言，一个长网址，在不同的地点，不同的用户等情况下，生成的短网址应该不一样，这样，在后端数据库中，可以更好的进行数据分析 #Highlight #[[2022-08-18]]
- 301是永久重定向，302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的。但是如果用了301， Google，百度等搜索引擎，搜索的时候会直接展示真实地址，那我们就无法统计到短地址被点击的次数了，也无法收集用户的Cookie, User Agent 等信息，这些信息可以用来做很多有意思的大数据分析，也是短网址服务商的主要盈利来源。所以，正确答案是302重定向。 #Highlight #[[2022-08-18]]
- DelayQueue 设计得非常巧妙，可以看做是一个特化版的PriorityBlockingQueue，它把计算时间差并让消费者等待该时间差的功能集成进了队列，消费者不需要关心时间差的事情了，直接在while(true)里不断take()就行了。 #Highlight #[[2022-08-18]]
- DelayQueue的设计其实是一个Leader/Follower模式，leader就是指向Leader线程的。该模式可以减少不必要的等待时间，当一个线程是Leader时，它只需要一个时间差；其他Follower线程则无限等待。比如头节点任务还有5秒就要开始了，那么Leader线程会sleep 5秒，不需要傻傻地等待固定时间间隔。 #Highlight #[[2022-08-18]]
- DelayQueue这个方案，每个消费者线程只需要等待所需要的时间差，因此响应速度更快。它内部用了一个优先队列，所以插入和删除的时间复杂度都是logn。 #Highlight #[[2022-08-18]]
- 因此每个任务需要有一个字段记录需圈数，每转一圈就减1，减到0则立刻取出来执行。 #Highlight #[[2022-08-18]]
- Netty中已经有了一个时间轮的实现, HashedWheelTimer.java，可以参考它的源代码。时间轮的优点是性能高，插入和删除的时间复杂度都是O(1)。Linux 内核中的定时器采用的就是这个方案 #Highlight #[[2022-08-18]]