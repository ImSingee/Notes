- #CruelFundamental [[2022-01-24]] #MySQL [讨论](https://github.com/Monsooooon/CruelFundamental/tree/main/homework/202201/24)
-
- # 隔离级别
- SQL 标准的[[事务]]隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）
-
- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
-
- # 实例
	- ![2022_01_24_image.png](https://cdn.logseq.com/%2Fa738fab4-25bd-41b0-bb53-62a3b83356f256d0c0bf-e879-406d-aaa3-afc96619132f2022_01_24_image.png?Expires=4796634751&Signature=DLRNB8YNNO4QIbAuPZR0~1PobuBnrH8uOZRhOiJ7Tc1VuPuBF34HiUMYtGHTI4L5TF42JUbBHG0YkPIDnevXQ1gG8aMCipOHCAXOBhD7SFPwKnIenoMZyCf8NARCuOFqgF77whbUruMnM6i7giH4e4b49132tM4nFZs6JWdd8ljR8Gsii5oYCoslSiYa4jge6GEiAw6c2-0oxNsQXraJu8n4Fe9OwWvPhfwZDotXWR08znyqTRFxuMhjB0bzXcFAhB8uovCXm85ZJ4tGTMDOuygWsJ0Q5wADy~0iK789Zup7sWPrQnsdWAH9WNcTKMLwKkXi3Huf~UmXC-~nhou-xA__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA){:width 300}
	- 在读未提交的情况下，所有的改动实时展现
		- V1=2, V2=2, V3=2
	- 在读提交的情况下，其他的事务改动只有在那个事务提交时才会展现
		- V1=1, V2=2, V3=2
	- 在可重复读的情况下，认为启动事务时「打了一个快照」，其他的事务影响仅会在当前事务提交后展现
		- V1=1, V2=1, V3=2
	- 在串行化的情况下，会涉及到读写锁，锁在相关记录被读写时获取、整个事务提交时才释放
		- A 查询时上读锁
		- B 查询时也上读锁（成功）
		- B 修改时上写锁，但因为 A 已经持有了读锁，因此会在这一步等待
		- A 查询得到值 V1=1
		- A查询得到值 V2=1
		- A 提交事务，读锁被释放
		- 这时上面第 3 步的 B 上写锁成功，将值改为 2
		- B 提交事务，写锁被释放
		- 事务 A 结束后查询的 V3=2（是否存在可能 V3=1？）
-
- # 默认隔离级别
- MySQL 是 RR
- Oracal 是 RC
- # 站在[[视图]]的角度去看隔离级别
	- RU 读未提交：不使用视图，始终使用行的当前值
	- RC 读提交：视图在每个 SQL 语句执行时创建，事务提交时提交
	- RR 可重复读：视图在事务开始时创建、事务提交时提交
		- 注意：事务开始 = 第一个 select，事务的启动不是 begin 就开始的
	- Serial 串行化：利用读写锁，不使用视图
- # 视图的原理
  collapsed:: true
	- 在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作（[[undo log]]）。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。
	- 假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。
	- ![2022_01_24_image.png](https://cdn.logseq.com/%2Fa738fab4-25bd-41b0-bb53-62a3b83356f2f5ab665e-2f19-480e-95f3-573b809021df2022_01_24_image.png?Expires=4796635963&Signature=IkmxTjlXniDK6SUMQFQCv3DLBGUmR42HaGpdqZDvVKSAiPiQImPILSANp~-PsqAjd6ZpFy3fmWBjhYnkeoMZOWnmCy6aHsHOVYKCCNttGwoT63j~3erA2HT51dvZJyU1Kgbnmpe2xe8O8rRBffQ8fWV9Zcit9DK-fC~mcL5cR2cICCQCfYEYMXwQw7BBGgK3sSjKHMyuoa7nxaq~e8nbE1S3OWtiNucPniLfkq6fosnjyfHUX2W2lL65b4Pw7oALwUUzF8bTMBpvCePitsk40yd~G2ms~38XDzYqF2QiyTgdqIADkByjFMixo48TxVL1rE9-GMks7i5UEklfeeUorg__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
	- 当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。
	- 对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。
- # 不使用隔离时的问题
- 脏读：读到其他事务未提交的数据【读提交解决】
- 不可重复读：前后读取的记录内容不一致【可重复读解决】
- 幻读：前后读取的记录数量不一致【串行化解决】
	- RR 模式下可利用间隙锁来解决幻读
-
- # 查询与设定隔离级别
- 查询隔离级别：`SELECT @@GLOBAL.transaction_isolation;`
- 设定隔离级别
	- `SET GLOBAL TRANSACTION ISOLATION  LEVEL READ UNCOMMITTED`
	- `SET GLOBAL TRANSACTION ISOLATION  LEVEL READ COMMITTED`
	- `SET GLOBAL TRANSACTION ISOLATION  LEVEL REPEATABLE READ`
	- `SET GLOBAL TRANSACTION ISOLATION  LEVEL SERIALIZABLE`
-
- 隔离级别的设定分为 GLOBAL、SESSION、Next Transaction 级别，具体请阅读文档
- # 参考
- [03 | 事务隔离：为什么你改了我还看不见？](https://time.geekbang.org/column/article/68963)
- [13.3.7 SET TRANSACTION Statement](https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html)
-
-