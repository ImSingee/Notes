alias:: Range Sum Query - Mutable

- #CruelCoding #2023-03-19 #Medium #[[Segment Tree]] [讲解](https://youtu.be/3faZ-iTte7k)
- #Algorithm #Medium #[[设计]] #[[数组]] #[[树状数组]] #[[线段树]]
- #Leetcode #Leetcode-307 [LC国际](https://leetcode.com/problems/range-sum-query-mutable/) [LC中国](https://leetcode.cn/problems/range-sum-query-mutable/)
- #lintcode #Lintcode-840 [LintCode](https://www.lintcode.com/problem/840/)
- # 题目
	- 给你一个数组 `nums` ，请你完成两类查询。
	- 其中一类查询要求 **更新** 数组 `nums` 下标对应的值
	- 另一类查询要求返回数组 `nums` 中索引 `left` 和索引 `right` 之间（ **包含**）的nums元素的 **和** ，其中 `left <= right`
	- 实现 `NumArray` 类：
	- `NumArray(int[] nums)` 用整数数组 `nums` 初始化对象
	- `void update(int index, int val)` 将 `nums[index]` 的值 **更新** 为 `val`
	- `int sumRange(int left, int right)` 返回数组 `nums` 中索引 `left` 和索引 `right` 之间（ **包含**）的nums元素的 **和** （即，`nums[left] + nums[left + 1], ..., nums[right]`）
	-
	- **示例 1：**
		- **输入**：
		- ["NumArray", "sumRange", "update", "sumRange"]
		- [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
		- **输出**：
		- [null, 9, null, 8]
		-
		- **解释**：
		- NumArray numArray = new NumArray([1, 3, 5]);
		- numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9
		- numArray.update(1, 2); // nums = [1,2,5]
		- numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8
		-
	- **提示：**
		- `1 <= nums.length <= 3 * 104`
		- `-100 <= nums[i] <= 100`
		- `0 <= index < nums.length`
		- `-100 <= val <= 100`
		- `0 <= left <= right < nums.length`
		- 调用 `update` 和 `sumRange` 方法次数不大于 `3 * 104`
- # 解
	- ## 树状数组
		- ```go
		  type NumArray struct {
		      a []int
		      c []int
		  }
		  
		  
		  func Constructor(nums []int) NumArray {
		      n := len(nums)
		      c := make([]int, n+1)
		  
		      for i := 1; i <= n; i++ {
		        c[i] += nums[i-1]
		        j := i + lowbit(i)
		        if j <= n {
		          c[j] += c[i]
		        }
		      }
		  
		      return NumArray{nums, c}
		  }
		  
		  
		  func (this *NumArray) Update(index int, val int)  {
		      k := val - this.a[index]
		  
		      x := index+1
		      n := len(this.a)
		      
		      this.a[index] = val
		  
		      for x <= n {
		        this.c[x] += k
		        x = x + lowbit(x)
		      }
		  }
		  
		  
		  func (this *NumArray) SumRange(left int, right int) int {
		      return this.getSumTo(right+1) - this.getSumTo(left)
		  }
		  
		  func (this *NumArray) getSumTo(x int) int {
		    sum := 0
		  
		    for x > 0 {
		      sum += this.c[x]
		      x = x - lowbit(x)
		    }
		  
		    return sum
		  }
		  
		  func lowbit(x int) int {
		    return x & -x
		  }
		  
		  
		  /**
		   * Your NumArray object will be instantiated and called as such:
		   * obj := Constructor(nums);
		   * obj.Update(index,val);
		   * param_2 := obj.SumRange(left,right);
		   */
		  ```
	- ### 线段树（动态开点）
		- ```go
		  type NumArray struct {
		      root *SegTreeNode
		  }
		  
		  
		  func Constructor(nums []int) NumArray {
		      gNums = nums
		      
		      n := len(nums)
		      root := NewNode(0, n-1)
		      root.Init()
		      
		      return NumArray {
		          root: root,
		      }
		  }
		  
		  
		  func (this *NumArray) Update(index int, val int)  {
		      this.root.Update(index, val)
		  }
		  
		  
		  func (this *NumArray) SumRange(left int, right int) int {
		      return this.root.QueryRange(left, right)
		  }
		  
		  var gNums []int
		  
		  type SegTreeNode struct {
		      left, right *SegTreeNode
		      start, end int
		      info int
		  }
		  
		  func NewNode(start, end int) *SegTreeNode {
		      return &SegTreeNode {
		          start: start, end: end,
		          info: 0,
		      }
		  }
		  
		  func (node *SegTreeNode) Init() {
		      if node.start == node.end {
		          node.info = gNums[node.start]
		          return
		      }
		      
		      mid := (node.start + node.end) / 2
		      node.left = NewNode(node.start, mid)
		      node.right = NewNode(mid+1, node.end)
		      
		      node.left.Init()
		      node.right.Init()
		      
		      node.info = node.left.info + node.right.info
		  }
		  
		  func (node *SegTreeNode) Update(idx int, val int) {
		      if idx < node.start || idx > node.end {
		          return
		      }
		      if node.start == node.end {
		          node.info = val
		          return
		      }
		      
		      node.left.Update(idx, val)
		      node.right.Update(idx, val)
		      
		      node.info = node.left.info + node.right.info
		  }
		  
		  func (node *SegTreeNode) QueryRange(left, right int) int {
		      if left > node.end || right < node.start {
		          return 0
		      }
		      if left <= node.start && node.end <= right {
		          return node.info
		      }
		      
		      return node.left.QueryRange(left, right) + node.right.QueryRange(left, right)
		  }
		  
		  
		  /**
		   * Your NumArray object will be instantiated and called as such:
		   * obj := Constructor(nums);
		   * obj.Update(index,val);
		   * param_2 := obj.SumRange(left,right);
		   */
		  
		  
		  ```