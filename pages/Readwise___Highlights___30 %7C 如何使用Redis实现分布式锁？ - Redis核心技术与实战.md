title:: Readwise/Highlights/30 | 如何使用Redis实现分布式锁？ - Redis核心技术与实战
author:: [[蒋德钧]]
full-title:: 30 | 如何使用Redis实现分布式锁？ - Redis核心技术与实战
category:: #articles
url:: https://time.geekbang.org/column/article/301092

- 共享存储系统保存了锁变量，如果共享存储系统发生故障或宕机，那么客户端也就无法进行锁操作了。在实现分布式锁时，我们需要考虑保证共享存储系统的可靠性，进而保证锁的可靠性。 #Highlight #[[2022-08-11]]
- 一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时。
  客户端只有在满足下面的这两个条件时，才能认为是加锁成功。
  条件一：客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁；
  条件二：客户端获取锁的总耗时没有超过锁的有效时间。
  在满足了这两个条件后，我们需要重新计算这把锁的有效时间，计算的结果是锁的最初有效时间减去客户端为获取锁的总耗时。 #Highlight #[[2022-08-11]]
- 加锁操作的超时时间需要远远地小于锁的有效时间，一般也就是设置为几十毫秒。 #Highlight #[[2022-08-11]]
- Redlock 算法的基本思路，是让客户端和多个独立的 Redis 实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁了，否则加锁失败。这样一来，即使有单个 Redis 实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失。 #Highlight #[[2022-08-11]]
- Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。 #Highlight #[[2022-08-11]]
- 要想保证操作的原子性，有两种通用的方法，分别是使用 Redis 的单命令操作和使用 Lua 脚本。 #Highlight #[[2022-08-11]]