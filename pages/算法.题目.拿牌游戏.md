- #动态规划 #算法/左神/体系学习班/18 [代码](https://github.com/singee-study/algorithm-java/blob/master/zuo-algorithm-2020/class18/Code02.java)
- ## 题目
- 给定一个整型数组arr，代表数值不同的纸牌排成一条线
  玩家A和玩家B依次拿走每张纸牌
  规定玩家A先拿，玩家B后拿
  但是每个玩家每次只能拿走最左或最右的纸牌
  玩家A和玩家B都绝顶聪明
  请返回最后获胜者的分数。
- ## 暴力递归
	- 这是一道比较复杂的题目，因为实际上存在两个表，我们需要同时考虑玩家 A 和 B 的最优决策
		- 先手玩家的最优策略是自己拿到最多的牌
		- 后手玩家的最优策略是自己拿到最多的牌 -> 尽可能让先手拿到最少的牌
	- 牌是可以从左右拿的
		- 对于先手玩家，拿到的分数应当是现在的牌 + 剩余牌的最优决策
		- 对于后手玩家，让先手拿到的分数应当是剩余牌的「最差」决策
		- 这里不存在贪心，只能动态规划
	- ```java
	  public static int method1(int[] cards) {
	    if (cards.length == 0) return 0;
	  
	    int AScore = f1(cards, 0, cards.length - 1);
	    int BScore = g1(cards, 0, cards.length-1);
	  
	    return Math.max(AScore, BScore);
	  }
	  
	  // 先手拿牌最大值
	  public static int f1(int[] cards, int L, int R) {
	    // 只剩下一张牌，拿掉
	    if (L == R) return cards[L];
	  
	    return Math.max(cards[L] + g1(cards, L + 1, R), cards[R] + g1(cards, L, R - 1));
	  }
	  
	  // 后手拿牌，让先手拿到的最小值
	  public static int g1(int[] cards, int L, int R) {
	    // 只剩下一张牌，先手无法得分
	    if (L == R) return 0;
	  
	    return Math.min(f1(cards, L + 1, R), f1(cards, L, R - 1));
	  }
	  ```
- ## 利用表缓存改写
	- 我们需要两张表来分别存储 f 和 g 函数的状态，观察可知
		- f 和 g 的变参均为 L、R
		- L R 的范围均为 [0, cars.length)