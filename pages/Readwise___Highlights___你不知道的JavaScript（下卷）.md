title:: Readwise/Highlights/你不知道的JavaScript（下卷）
author:: [[凯尔·辛普森]]
full-title:: 你不知道的JavaScript（下卷）
category:: #books
- 元属性以属性访问的形式提供特殊的其他方法无法获取的元信息。 #Highlight #[[2023-04-26]]
- 代理是一种由你创建的特殊的对象，它“封装”另一个普通对象——或者说挡在这个普通对象的前面。你可以在代理对象上注册特殊的处理函数（也就是trap），代理上执行各种操作的时候会调用这个程序。这些处理函数除了把操作转发给原始目标/被封装对象之外，还有机会执行额外的逻辑。 #Highlight #[[2023-04-26]]
- 元编程关注以下一点或几点：代码查看自身、代码修改自身、代码修改默认语言特性，以此影响其他代码 #Highlight #[[2023-04-26]]
- 元编程的目标是利用语言自身的内省能力使代码的其余部分更具描述性、表达性和灵活性。 #Highlight #[[2023-04-26]]
- 我们需要确定函数的“名称”是否就是它的name属性（是的，函数有一个名为name的属性），或者它是否指向其词法绑定名称 #Highlight #[[2023-04-26]]
- 每个可用的代理trap都有一个对应的同名Reflect函数即可 #Highlight #[[2023-04-26]]
- 对于所有的元编程技术都要小心，不要编写过于机灵的代码，让未来的你或者其他代码维护者难以理解。要小心使用这些技巧。 #Highlight #[[2023-04-26]]
- 每个代理处理函数在对应的元编程任务执行的时候进行拦截，而每个Reflect工具在一个对象上执行相应的元编程任务 #Highlight #[[2023-04-26]]
- 默认情况下函数的词法名称（如果有的话）也会被设为它的name属性 #Highlight #[[2023-04-26]]
- 事实表明，有时候你的ES6 JavaScript程序能够完整“原生”运行在ES6+浏览器中，但有时候又需要transpilation运行在前ES6浏览器中。如果总是加载使用transpile的代码，甚至在新的ES6兼容环境中也是这样，那么至少有时候是在运行非优化的代码。这并不理想。 #Highlight #[[2023-05-01]]
- 原型（或实例本身）的@@toStringTag符号指定了在[object ]字符串化时使用的字符串值。 #Highlight #[[2023-04-26]]
- @@hasInstance符号是在构造器函数上的一个方法，接受实例对象值，通过返回true或false来指示这个值是否可以被认为是一个实例。 #Highlight #[[2023-04-26]]
- 默认情况下，name属性不可写，但可配置，也就是说如果需要的话，可使用Object. defineProperty(..)来手动修改。 #Highlight #[[2023-04-26]]
- 对于ES6来说，Reflect.ownKeys(..)、Object.getOwnPropertyNames(..)和Object.getOwnPropertySymbols(..)的顺序都是可预测且可靠的，这由规范保证。所以依赖于这个顺序的代码是安全的。
  Reflect.enumerate(..)、Object.keys(..)和for..in（以及扩展的JSON.stringification(..)）还像过去一样，可观察的顺序是相同的。但是这个顺序不再必须与Reflect.ownKeys(..)相同。在使用它们依赖于具体实现的顺序时仍然要小心。 #Highlight #[[2023-04-27]]
- 和new Proxy(..)不一样，Proxy.revocable(..)的返回值不是代理本身。而是一个有两个属性——proxy和revode的对象 #Highlight #[[2023-04-26]]
- 一旦可取消代理被取消，任何对它的访问（触发它的任意trap）都会抛出TypeError #Highlight #[[2023-04-26]]
- 可取消代理的一个可能应用场景是，在你的应用中把代理分发到第三方，其中管理你的模型数据，而不是给出真实模型本身的引用。如果你的模型对象改变或者被替换，就可以使分发出去的代理失效，这样第三方能够（通过错误！）知晓变化并请求更新到这个模型的引用。 #Highlight #[[2023-04-26]]