title:: Readwise/Highlights/01｜虚拟内存：为什么可用内存会远超物理内存？ - 编程高手必学的内存知识
author:: [[海纳]]
full-title:: 01｜虚拟内存：为什么可用内存会远超物理内存？ - 编程高手必学的内存知识
category:: #articles
url:: https://time.geekbang.org/column/article/430073
- 虚拟内存的出现，是为了解决直接操作物理内存的系统无法支持多进程的问题。这里的难点主要是进程的地址空间非常小，而且多个进程的地址很容易发生冲突。所以在局部性原理的基础上，CPU 设计者提出虚拟内存的方案将多个进程的地址空间隔离开，并且提供了巨大的内存空间。 #Highlight #[[2022-11-21]]
- 映射的过程，是由 CPU 的内存管理单元 (Memory Management Unit, MMU) 自动完成的，但它依赖操作系统设置的页表。 #Highlight #[[2023-04-18]]
- 任何虚拟内存最终都要映射到物理内存，但虚拟内存的大小又远超真实的物理内存的大小。 #Highlight #[[2022-11-21]]
- CPU 和操作系统还联手编织了一个假象：每个进程都独享 128T 的虚拟内存空间，并且每个进程的地址空间都是相互隔离的。 #Highlight #[[2022-11-21]]
- 无论一个进程占用的内存资源有多大，在任一时刻，它需要的物理内存都是很少的。 #Highlight #[[2022-11-21]]
- PTE 中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。 #Highlight #[[2023-04-18]]
- 由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的。这就解决了多进程之间地址冲突的问题。 #Highlight #[[2023-04-18]]
- 从效率的角度看，当物理内存足够时，操作系统也会尽量让尽可能多的页驻留在物理内存中。毕竟将内存中的数据写到磁盘里是非常耗时的操作。 #Highlight #[[2023-04-18]]
- 由于程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性。那对于那些没有被经常使用到的内存，我们可以把它换出到主存之外，比如硬盘上的 swap 区域 #Highlight #[[2023-04-18]]
- 在 64 位的机器上，使用了 48 位的虚拟地址，所以它需要使用 4 级页表。它的结构与 32 位的 3 级页表是相似的，只是多了一级页目录，定位的过程也从 32 位的 4 步变成了 5 步。 #Highlight #[[2023-04-18]]
- 第一步是确定页目录基址。每个 CPU 都有一个页目录基址寄存器，最高级页表的基地址就存在这个寄存器里。在 X86 上，这个寄存器是 CR3。每一次计算物理地址时，MMU 都会从 CR3 寄存器中取出页目录所在的物理地址。
  第二步是定位页目录项（PDE）。一个 32 位的虚拟地址可以拆成 10 位，10 位和 12 位三段，上一步找到的页目录表基址加上高 10 位的值乘以 4，就是页目录项的位置。这是因为，一个页目录项正好是 4 字节，所以 1024 个页目录项共占据 4096 字节，刚好组成一页，而 1024 个页目录项需要 10 位进行编码。这样，我们就可以通过最高 10 位找到该地址所对应的 PDE 了。
  第三步是定位页表项（PTE）。页目录项里记录着页表的位置，CPU 通过页目录项找到页表的位置以后，再用中间 10 位计算页表中的偏移，可以找到该虚拟地址所对应的页表项了。页表项也是 4 字节的，所以一页之内刚好也是 1024 项，用 10 位进行编码。所以计算公式与上一步相似，用页表基址加上中间 10 位乘以 4，可以得到页表项的地址。
  最后一步是确定真实的物理地址。上一步 CPU 已经找到页表项了，这里存储着物理地址，这才真正找到该虚拟地址所对应的物理页。虚拟地址的低 12 位，刚好可以对一页内的所有字节进行编码，所以我们用低 12 位来代表页内偏移。计算的公式是物理页的地址直接加上低 12 位。 #Highlight #[[2023-04-18]]
- 一个 CPU 要通过虚拟地址，找到物理地址需要几个步骤呢？大概是下面这四个。 #Highlight #[[2023-04-18]]
- 页目录表中的每一项叫做页目录项 (Page Directory Entry, PDE)，每个 PDE 都对应一个页表，它记录了页表开始处的物理地址，这就是多级页表结构。 #Highlight #[[2023-04-18]]
- 一个页表项对应着一个大小为 4K 的页，所以 1024 个页表项所能支持的空间就是 4M。那为了编码更多地址，我们必须使用更多的页表。而且，为了管理这些页表，我们还可以继续引入页表的数组：页目录表。 #Highlight #[[2023-04-18]]
- i7 处理器的页表也是存储在内存页里的，每个页表项都是 4 字节。 #Highlight #[[2023-04-18]]
- 页表的本质是页表项 (Page Table Entry, PTE) 的数组，虚拟空间中的每一个页在页表中都有一个 PTE 与之对应，PTE 中会记录这个虚拟内存页所对应的实际物理页的起始地址 #Highlight #[[2023-04-18]]
- 计算机的虚拟内存大小是不一样的。虚拟地址空间往往与机器字宽有关系。例如 32 位机器上，指向内存的指针是 32 位的，所以它的虚拟地址空间是 2 的 32 次方，也就是 4G。在 64 位机器上，指向内存的指针就是 64 位的，但在 64 位系统里只使用了低 48 位，所以它的虚拟地址空间是 2 的 48 次方，也就是 256T。 #Highlight #[[2023-04-18]]
- 在虚拟内存中连续的页面，在物理内存中不必是连续的。只要维护好从虚拟内存页到物理内存页的映射关系，你就能正确地使用内存了。这种映射关系是操作系统通过页表来自动维护的，不必你操心。 #Highlight #[[2023-04-18]]
- 在你得到一块虚拟内存以后，这块内存就是未映射状态，因为它并没有被映射到相应的物理内存，直到对该块内存进行读写时，操作系统才会真正地为它分配物理内存。然后这个页面才能成为正常页面。 #Highlight #[[2023-04-18]]
- 虽然虚拟内存提供了很大的空间，但实际上进程启动之后，这些空间并不是全部都能使用的。开发者必须要使用 malloc 等分配内存的接口才能将内存从待分配状态变成已分配状态。 #Highlight #[[2023-04-18]]
- 这种映射关系是以页为单位的。你看看下面这张图就很好理解了，多个进程的虚拟内存中的页都被映射到物理内存页上。 #Highlight #[[2023-04-18]]
- CPU 充分利用程序局部性原理，提出了虚拟内存和物理内存的映射 (Mapping) 机制 #Highlight #[[2023-04-18]]
- 任何虚拟内存最终都要映射到物理内存，但虚拟内存的大小又远超真实的物理内存的大小 #Highlight #[[2023-04-18]]
- 为了让程序员编程方便，CPU 和操作系统还联手编织了一个假象：每个进程都独享 128T 的虚拟内存空间，并且每个进程的地址空间都是相互隔离的 #Highlight #[[2023-04-18]]
- 无论一个进程占用的内存资源有多大，在任一时刻，它需要的物理内存都是很少的 #Highlight #[[2023-04-18]]
- 我们可以从两个方面来理解局部性原理。第一个方面是时间局部性，也就是说被访问过一次的内存位置很可能在不远的将来会被再次访问；另一方面是空间局部性，说的是如果一个内存位置被引用过，那么它邻近的位置在不远的将来也有很大概率会被访问。 #Highlight #[[2023-04-18]]
- 在绝大多数程序的运行过程中，当前指令大概率都会引用最近访问过的数据。也就是说，程序的数据访问会表现出明显的倾向性。这种倾向性，我们就称之为局部性原理 (Principle of locality)。 #Highlight #[[2023-04-18]]
- 基于局部性原理，CPU 为程序员虚拟化了一层内存，我们只需要与虚拟内存打交道就可以了 #Highlight #[[2023-04-18]]
- 在嵌入式设备中，手动管理内存的操作还是广泛存在的。这是因为在嵌入式开发中，往往没有进程的概念，也就是说整个应用独享全部内存，所以手动管理内存才有可能性。在单进程的系统中，所有的物理资源都是单一进程在管理，直接管理物理内存的操作复杂度还可以接受。尽管如此，嵌入式开发中手动管理内存仍然是一项对程序员要求极高的工作。 #Highlight #[[2023-04-18]]
- 直接访问物理内存，存在着一个很大的问题。
  因为这种模式下，必然要求程序员手动对数据进行布局，那么内存不够用怎么办呢？而且，每个进程分配多少内存、如何保证指令中访存地址的正确性，这些问题都全部要程序员来负责。 #Highlight #[[2023-04-18]]
- 至今，X86 架构的 CPU 在上电以后，为了与 8086 保持兼容，还是运行在 16 位实模式下，实模式的特点是所有访存指令访问的都是物理内存地址。 #Highlight #[[2023-04-18]]
- 计算机的主存是由多个连续的单元组成的，每个单元称为一个字节，每个字节都有一个唯一的物理地址 (Physical Address， PA)，地址编码是从 0 开始的。所以，如果计算机上配有 2G 的内存，那么，这个计算机可用的物理内存空间就是 0 到 2G。 #Highlight #[[2023-04-18]]
- 虚拟内存可以充分使用 CPU 提供的机制来完成很多重要的任务。例如，fork 借用写保护来实现写时复制，JVM 中借用改变某一个页的读权限来实现 safepoint 查询等等 #Highlight #[[2023-04-18]]