alias:: DDIA/ch8

- [link](https://github.com/Vonng/ddia/blob/master/ch8.md)
- 系统如何处理错误
	- **副本故障切换**
	- **复制延迟**
	- 事务控制
- *尽管我们已经谈了很多错误，但之前几章仍然过于乐观。现实更加黑暗*
	- 我们现在将悲观主义最大化，假设任何可能出错的东西 **都会** 出错
	- **这是一个合理的假设**
- 使用分布式系统与在一台计算机上编写软件有着根本的区别，主要的区别在于，有许多新颖和刺激的方法可以使事情出错
-
## 故障与部分失效
	- 单个计算机上的软件没有根本性的不可靠原因：当硬件正常工作时，相同的操作总是产生相同的结果（这是确定性的）。如果存在硬件问题（例如，内存损坏或连接器松动），其后果通常是整个系统故障（例如，内核恐慌，“蓝屏死机”，启动失败）。装有良好软件的个人计算机通常要么功能完好，要么完全失效，而不是介于两者之间。
	- **计算机设计中的一个有意的选择：如果发生内部错误，我们宁愿电脑完全崩溃，而不是返回错误的结果**
	- 在分布式系统中，尽管系统的其他部分工作正常，但系统的某些部分可能会以某种不可预知的方式被破坏。这被称为 **部分失效（partial failure）**。难点在于部分失效是 **不确定性的（nondeterministic）**：如果你试图做任何涉及多个节点和网络的事情，它有时可能会工作，有时会出现不可预知的失败
	- ### 云计算与超级计算机
		- 构建大型计算系统的两个极端
			- 一个极端是高性能计算（HPC）领域。具有数千个 CPU 的超级计算机通常用于计算密集型科学计算任务
			- 另一个极端是 **云计算（cloud computing）**
			- 传统企业数据中心位于这两个极端之间
		- 如果要使分布式系统工作，就必须接受部分故障的可能性，并在软件中建立容错机制
		- 换句话说，我们需要从不可靠的组件构建一个可靠的系统
## 不可靠的网络
	- 我们在本书中关注的分布式系统是无共享的系统，即通过网络连接的一堆机器。网络是这些机器可以通信的唯一途径 —— 我们假设每台机器都有自己的内存和磁盘，一台机器不能访问另一台机器的内存或磁盘（除了通过网络向服务器发出请求）
	- **无共享** 并不是构建系统的唯一方式，但它已经成为构建互联网服务的主要方式，其原因如下：相对便宜，因为它不需要特殊的硬件，可以利用商品化的云计算服务，通过跨多个地理分布的数据中心进行冗余可以实现高可靠性
	- 互联网和数据中心（通常是以太网）中的大多数内部网络都是 **异步分组网络（asynchronous packet networks）**。在这种网络中，一个节点可以向另一个节点发送一个消息（一个数据包），但是网络不能保证它什么时候到达，或者是否到达。如果你发送请求并期待响应，则很多事情可能会出错
		- 请求已经丢失 / 排队 / 延迟 / 乱序
		- 远程节点可能已经失效 / 暂时停止响应 / 超时响应
		- 远程节点可能已经处理了请求，但是网络上的响应已经丢失
	- **发送者甚至不能分辨数据包是否被发送**，超时时，**仍然不知道远程节点是否收到了请求**
		- 请求可能完全丢失
		- 可能仍然在排队
		- 可能只是响应丢失
	- ### 真实世界的网络故障
		- 诸如 EC2 之类的公有云服务因频繁的暂态网络故障而臭名昭著，管理良好的私有数据中心网络可能是更稳定的环境
			- **云服务是为了弹性，不是为了可靠**
		- 网络分区
			- 网络接口有时会丢弃所有入站数据包，但是成功发送出站数据包，**仅仅因为网络链接在一个方向上工作，并不能保证它也在相反的方向工作**
			- 当网络的一部分由于网络故障而被切断时，有时称为 **网络分区（network partition）** 或 **网络断裂（netsplit）**
	- ### 检测故障
		- 许多系统需要自动检测故障节点。例如：
			- 负载平衡器需要停止向已死亡的节点转发请求（从轮询列表移出，即 out of rotation）。
			- 在单主复制功能的分布式数据库中，如果主库失效，则需要将从库之一升级为新主库
		- **网络的不确定性使得很难判断一个节点是否工作**
		- 如果出了什么问题，你可能会在堆栈的某个层次上得到一个错误响应，但总的来说，你必须假设你可能根本就得不到任何回应。你可以重试几次（TCP 重试是透明的，但是你也可以在应用程序级别重试），等待超时过期，并且如果在超时时间内没有收到响应，则最终声明节点已经死亡
	- ### 超时与无穷的延迟
		- **超时是检测故障的唯一可靠方法**
		- 等待多久？
			- 短的超时可以更快地检测到故障，但有更高地风险误将一个节点宣布为失效，而该节点实际上只是暂时地变慢了
				- 过早地声明一个节点已经死了是有问题的：如果这个节点实际上是活着的，并且正在执行一些动作（例如，发送一封电子邮件），而另一个节点接管，那么这个动作可能会最终执行两次
				- 如果系统已经处于高负荷状态，则过早宣告节点死亡会使问题更严重。特别是如果节点实际上没有死亡，只是由于过载导致其响应缓慢；这时将其负载转移到其他节点可能会导致 **级联失效**（即 cascading failure，表示在极端情况下，所有节点都宣告对方死亡，所有节点都将停止工作）
			- 长时间的超时意味着长时间等待，直到一个节点被宣告死亡（在这段时间内，用户可能不得不等待，或者看到错误信息）
		- #### 网络拥塞和排队
			- 计算机网络上数据包延迟的可变性通常是由于排队
				- 网络交换机要求排队
				- 目标机 CPU 要求排队
				- 虚拟化环境虚拟机监视器要求排队
				- TCP 执行 **流量控制**（flow control，也称为 **拥塞避免**，即 congestion avoidance，或 **背压**，即 backpressure），发送端可能被要求排队
			- 一些对延迟敏感的应用程序，比如视频会议和 IP 语音（VoIP），使用了 UDP 而不是 TCP。这是在可靠性和和延迟变化之间的折衷：由于 UDP 不执行流量控制并且不重传丢失的分组，所以避免了网络延迟变化的一些原因
				- 在延迟数据毫无价值的情况下，UDP 是一个不错的选择。例如，在 VoIP 电话呼叫中，可能没有足够的时间重新发送丢失的数据包，并在扬声器上播放数据。在这种情况下，重发数据包没有意义 —— 应用程序必须使用静音填充丢失数据包的时隙（导致声音短暂中断），然后在数据流中继续。重试发生在人类层。 （“你能再说一遍吗？声音刚刚断了一会儿。“）
	- ### 同步网络与异步网络
		- 如果我们可以依靠网络来传递一些 **最大延迟固定** 的数据包，而不是丢弃数据包，那么分布式系统就会简单得多
		- **传统固定电话网络（非蜂窝，非 VoIP）**
			- 当你通过电话网络拨打电话时，它会建立一个电路：在两个呼叫者之间的整个路线上为呼叫分配一个固定的，有保证的带宽量。这个电路会保持至通话结束
			- 例如，ISDN 网络以每秒 4000 帧的固定速率运行。呼叫建立时，每个帧内（每个方向）分配 16 位空间。因此，在通话期间，每一方都保证能够每 250 微秒发送一个精确的 16 位音频数据
			- 这种网络是同步的：即使数据经过多个路由器，也不会受到排队的影响，因为呼叫的 16 位空间已经在网络的下一跳中保留了下来。而且由于没有排队，网络的最大端到端延迟是固定的。我们称之为 **有限延迟（bounded delay）**
		- #### 我们不能简单地使网络延迟可预测吗？
			- 电话网络中的电路与 TCP 连接有很大不同：电路是固定数量的预留带宽，在电路建立时没有其他人可以使用，而 TCP 连接的数据包 **机会性地** 使用任何可用的网络带宽
			- 以太网和 IP 是 **分组交换协议**
				- 什么数据中心网络和互联网使用分组交换？答案是，它们针对 **突发流量（bursty traffic）** 进行了优化
			- 已经有一些尝试去建立同时支持电路交换和分组交换的混合网络，比如 ATM
				- 链路层实现了端到端的流量控制，从而减少了在网络中排队的需要，尽管它仍然可能因链路拥塞而受到延迟
				- 通过仔细使用 **服务质量**（quality of service，即 QoS，数据包的优先级和调度）和 **准入控制**（admission control，限速发送器），可以在分组网络上模拟电路交换，或提供统计上的 **有限延迟**
			- 目前在多租户数据中心和公共云或通过互联网进行通信时，此类服务质量尚未启用。当前部署的技术不允许我们对网络的延迟或可靠性作出任何保证：我们必须假设网络拥塞，排队和无限的延迟总是会发生。因此，超时时间没有 “正确” 的值 —— 它需要通过实验来确定
	- ### 延迟和资源利用
		- 更一般地说，可以将 **延迟变化** 视为 **动态资源分区** 的结果。
		- 如果资源是静态分区的（例如，专用硬件和专用带宽分配），则在某些环境中可以实现 **延迟保证**。但是，这是以降低利用率为代价的 —— 换句话说，它是更昂贵的。另一方面，动态资源分配的多租户提供了更好的利用率，所以它更便宜，但它具有可变延迟的缺点。
		- 网络如此，CPU 分时也是如此
## 不可靠的时钟
	- 时钟和时间很重要。应用程序以各种方式依赖于时钟来回答以下问题
		- **持续时间**（durations，例如，请求发送与响应接收之间的时间间隔）
			- 这个请求是否超时了？
			- 这项服务的第 99 百分位响应时间是多少？
			- 在过去五分钟内，该服务平均每秒处理多少个查询？
			- 用户在我们的网站上花了多长时间？
		- **时间点**（point in time，在特定日期和和特定时间发生的事件）
			- 这篇文章在何时发布？
			- 在什么时间发送提醒邮件？
			- 这个缓存条目何时到期？
			- 日志文件中此错误消息的时间戳是什么？
	- **在分布式系统中，时间是一件棘手的事情**
		- 因为通信不是即时的：消息通过网络从一台机器传送到另一台机器需要时间。收到消息的时间总是晚于发送的时间，但是由于网络中的可变延迟，我们不知道晚了多少时间。这个事实导致有时很难确定在涉及多台机器时发生事情的顺序
		- 网络上的每台机器都有自己的时钟，可能比其他机器稍快或更慢。可以在一定程度上同步时钟：最常用的机制是 **网络时间协议（NTP）**，它允许根据一组服务器报告的时间来调整计算机时钟
	- ### 单调钟与日历时钟
		- 现代计算机至少有两种不同的时钟：日历时钟（time-of-day clock）和单调钟（monotonic clock）。尽管它们都衡量时间，但区分这两者很重要，因为它们有不同的目的。
		- #### 日历时钟
			- 日历时钟是你直观地了解时钟的依据：它根据某个日历（也称为 **挂钟时间**，即 wall-clock time）返回当前日期和时间
				- 通常为 Linux 时间戳，返回自 epoch（UTC 时间 1970 年 1 月 1 日午夜）以来的秒数（或毫秒），根据公历（Gregorian）日历，不包括闰秒
			- 日历时钟通常与 NTP 同步，这意味着来自一台机器的时间戳（理想情况下）与另一台机器上的时间戳相同
				- **但是 如果本地时钟在 NTP 服务器之前太远，则它可能会被强制重置，看上去好像跳回了先前的时间点**。这些跳跃以及他们经常忽略闰秒的事实，使日历时钟不能用于测量经过时间（elapsed time）
		- #### 单调钟
			- 单调钟适用于测量持续时间（时间间隔），例如超时或服务的响应时间
			- 这个名字来源于他们保证总是往前走的事实（而日历时钟可以往回跳）
			- 单调钟的绝对值是毫无意义的：它可能是计算机启动以来的纳秒数，或类似的任意值。特别是比较来自两台不同计算机的单调钟的值是没有意义的，因为它们并不是一回事
			- 在具有多个 CPU 插槽的服务器上，每个 CPU 可能有一个单独的计时器，但不一定与其他 CPU 同步。操作系统会补偿所有的差异，并尝试向应用线程表现出单调钟的样子，即使这些线程被调度到不同的 CPU 上。当然，**明智的做法是不要太把这种单调性保证当回事**
			-
	- ### 时钟同步与准确性
	- ### 依赖同步时钟
		- #### 有序事件的时间戳
		- #### 时钟读数存在置信区间
		- #### 全局快照的同步时钟
	- ### 进程暂停
		- #### 响应时间保证
		- #### 限制垃圾收集的影响
## 知识、真相与谎言
	- ### 真相由多数所定义
		- #### 领导者和锁
		- #### 防护令牌
	- ### 拜占庭故障
	- ### 系统模型与现实
		- #### 算法的正确性
		- #### 安全性和活性
		- #### 将系统模型映射到现实世界
## 本章小结
	-