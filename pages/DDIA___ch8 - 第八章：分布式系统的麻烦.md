alias:: DDIA/ch8

- [link](https://github.com/Vonng/ddia/blob/master/ch8.md)
- 系统如何处理错误
	- **副本故障切换**
	- **复制延迟**
	- 事务控制
- *尽管我们已经谈了很多错误，但之前几章仍然过于乐观。现实更加黑暗*
	- 我们现在将悲观主义最大化，假设任何可能出错的东西 **都会** 出错
	- **这是一个合理的假设**
- 使用分布式系统与在一台计算机上编写软件有着根本的区别，主要的区别在于，有许多新颖和刺激的方法可以使事情出错
-
## 故障与部分失效
	- 单个计算机上的软件没有根本性的不可靠原因：当硬件正常工作时，相同的操作总是产生相同的结果（这是确定性的）。如果存在硬件问题（例如，内存损坏或连接器松动），其后果通常是整个系统故障（例如，内核恐慌，“蓝屏死机”，启动失败）。装有良好软件的个人计算机通常要么功能完好，要么完全失效，而不是介于两者之间。
	- **计算机设计中的一个有意的选择：如果发生内部错误，我们宁愿电脑完全崩溃，而不是返回错误的结果**
	- 在分布式系统中，尽管系统的其他部分工作正常，但系统的某些部分可能会以某种不可预知的方式被破坏。这被称为 **部分失效（partial failure）**。难点在于部分失效是 **不确定性的（nondeterministic）**：如果你试图做任何涉及多个节点和网络的事情，它有时可能会工作，有时会出现不可预知的失败
	- ### 云计算与超级计算机
		- 构建大型计算系统的两个极端
			- 一个极端是高性能计算（HPC）领域。具有数千个 CPU 的超级计算机通常用于计算密集型科学计算任务
			- 另一个极端是 **云计算（cloud computing）**
			- 传统企业数据中心位于这两个极端之间
		- 如果要使分布式系统工作，就必须接受部分故障的可能性，并在软件中建立容错机制
		- 换句话说，我们需要从不可靠的组件构建一个可靠的系统
## 不可靠的网络
	- 我们在本书中关注的分布式系统是无共享的系统，即通过网络连接的一堆机器。网络是这些机器可以通信的唯一途径 —— 我们假设每台机器都有自己的内存和磁盘，一台机器不能访问另一台机器的内存或磁盘（除了通过网络向服务器发出请求）
	- **无共享** 并不是构建系统的唯一方式，但它已经成为构建互联网服务的主要方式，其原因如下：相对便宜，因为它不需要特殊的硬件，可以利用商品化的云计算服务，通过跨多个地理分布的数据中心进行冗余可以实现高可靠性
	- 互联网和数据中心（通常是以太网）中的大多数内部网络都是 **异步分组网络（asynchronous packet networks）**。在这种网络中，一个节点可以向另一个节点发送一个消息（一个数据包），但是网络不能保证它什么时候到达，或者是否到达。如果你发送请求并期待响应，则很多事情可能会出错
		- 请求已经丢失 / 排队 / 延迟 / 乱序
		- 远程节点可能已经失效 / 暂时停止响应 / 超时响应
		- 远程节点可能已经处理了请求，但是网络上的响应已经丢失
	- **发送者甚至不能分辨数据包是否被发送**，超时时，**仍然不知道远程节点是否收到了请求**
		- 请求可能完全丢失
		- 可能仍然在排队
		- 可能只是响应丢失
	- ### 真实世界的网络故障
		- 诸如 EC2 之类的公有云服务因频繁的暂态网络故障而臭名昭著，管理良好的私有数据中心网络可能是更稳定的环境
			- **云服务是为了弹性，不是为了可靠**
		- 网络分区
			- 网络接口有时会丢弃所有入站数据包，但是成功发送出站数据包，**仅仅因为网络链接在一个方向上工作，并不能保证它也在相反的方向工作**
			- 当网络的一部分由于网络故障而被切断时，有时称为 **网络分区（network partition）** 或 **网络断裂（netsplit）**
	- ### 检测故障
		- 许多系统需要自动检测故障节点。例如：
			- 负载平衡器需要停止向已死亡的节点转发请求（从轮询列表移出，即 out of rotation）。
			- 在单主复制功能的分布式数据库中，如果主库失效，则需要将从库之一升级为新主库
		- **网络的不确定性使得很难判断一个节点是否工作**
		- 如果出了什么问题，你可能会在堆栈的某个层次上得到一个错误响应，但总的来说，你必须假设你可能根本就得不到任何回应。你可以重试几次（TCP 重试是透明的，但是你也可以在应用程序级别重试），等待超时过期，并且如果在超时时间内没有收到响应，则最终声明节点已经死亡
	- ### 超时与无穷的延迟
		- **超时是检测故障的唯一可靠方法**
		- 等待多久？
			- 短的超时可以更快地检测到故障，但有更高地风险误将一个节点宣布为失效，而该节点实际上只是暂时地变慢了
				- 过早地声明一个节点已经死了是有问题的：如果这个节点实际上是活着的，并且正在执行一些动作（例如，发送一封电子邮件），而另一个节点接管，那么这个动作可能会最终执行两次
				- 如果系统已经处于高负荷状态，则过早宣告节点死亡会使问题更严重。特别是如果节点实际上没有死亡，只是由于过载导致其响应缓慢；这时将其负载转移到其他节点可能会导致 **级联失效**（即 cascading failure，表示在极端情况下，所有节点都宣告对方死亡，所有节点都将停止工作）
			- 长时间的超时意味着长时间等待，直到一个节点被宣告死亡（在这段时间内，用户可能不得不等待，或者看到错误信息）
			-
			-
		- #### 网络拥塞和排队
	- ### 同步网络与异步网络
		- #### 我们不能简单地使网络延迟可预测吗？
## 不可靠的时钟
	- ### 单调钟与日历时钟
		- #### 日历时钟
		- #### 单调钟
	- ### 时钟同步与准确性
	- ### 依赖同步时钟
		- #### 有序事件的时间戳
		- #### 时钟读数存在置信区间
		- #### 全局快照的同步时钟
	- ### 进程暂停
		- #### 响应时间保证
		- #### 限制垃圾收集的影响
## 知识、真相与谎言
	- ### 真相由多数所定义
		- #### 领导者和锁
		- #### 防护令牌
	- ### 拜占庭故障
	- ### 系统模型与现实
		- #### 算法的正确性
		- #### 安全性和活性
		- #### 将系统模型映射到现实世界
## 本章小结
	-