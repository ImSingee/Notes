title:: Readwise/Highlights/Chapter 1. Introduction and Overview 第 1 章 导言...
author:: [[O'Reilly Online Learning]]
full-title:: Chapter 1. Introduction and Overview 第 1 章 导言和概述导言和概述
category:: #articles
url:: https://learning.oreilly.com/library/view/database-internals/9781492040330/ch01.html

- some sources group DBMSs into three major categories ... Online transaction processing (OLTP) databases ... Online analytical processing (OLAP) databases ... Hybrid transactional and analytical processing (HTAP) #Highlight #[[2023-11-09]]
- ![dbin 0101](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492040330/files/assets/dbin_0101.png)Figure 1-1. Architecture of a database management system  
  图 1-1.数据库管理系统的结构 ([View Highlight](https://read.readwise.io/read/01hesjdd2kfht4vj72vn24v8ky)) #Highlight #[[2023-11-09]]
- The storage engine has several components with dedicated responsibilities: ... Transaction manager ... Lock manager ... Access methods (storage structures) ... Buffer manager ... Recovery manager #Highlight #[[2023-11-09]]
- Together, transaction and lock managers are responsible for concurrency control (see [“Concurrency Control”](https://learning.oreilly.com/library/view/database-internals/9781492040330/ch01.html/ch05.html#b_tree_concurrency)): they guarantee logical and physical data integrity while ensuring that concurrent operations are executed as efficiently as possible. ([View Highlight](https://read.readwise.io/read/01hesjftska13a2nfdyc8x7s5m)) #Highlight #[[2023-11-09]]
- Database systems store data in memory and on disk. *In-memory database management systems* (sometimes called *main memory DBMS*) store data *primarily* in memory and use the disk for recovery and logging. *Disk-based* DBMS hold *most* of the data on disk and use memory for caching disk contents or as a temporary storage. ([View Highlight](https://read.readwise.io/read/01hesjjnay42dvdtkxwe27zngr)) #Highlight #[[2023-11-09]]
- Main memory database systems are different from their disk-based counterparts not only in terms of a primary storage medium, but also in which data structures, organization, and optimization techniques they use. ([View Highlight](https://read.readwise.io/read/01hesjj83vve1vb9k480sxjt79)) #Highlight #[[2023-11-09]]
- Operating systems abstract memory management and allow us to think in terms of allocating and freeing arbitrarily sized memory chunks. On disk, we have to manage data references, serialization formats, freed memory, and fragmentation manually. ([View Highlight](https://read.readwise.io/read/01hesjk5cw4664tfe09bevvzj3)) #Highlight #[[2023-11-09]]
- Before the operation can be considered complete, its results have to be written to a sequential log file. We discuss write-ahead logs in more detail in [“Recovery”](https://learning.oreilly.com/library/view/database-internals/9781492040330/ch01.html/ch05.html#write_ahead_log). To avoid replaying complete log contents during startup or after a crash, in-memory stores maintain a *backup copy*. The backup copy is maintained as a sorted disk-based structure, and modifications to this structure are often asynchronous (decoupled 解耦 from client requests) and applied in batches to reduce the number of I/O operations. During recovery, database contents can be restored from the backup and logs. ([View Highlight](https://read.readwise.io/read/01hesjnv29qcxwvyr5ktyjr1kb)) #Highlight #[[2023-11-09]]
- Log records are usually applied to backup in batches. After the batch of log records is processed, backup holds a database *snapshot* for a specific point in time, and log contents up to this point can be discarded. This process is called *checkpointing*. It reduces recovery times by keeping the disk-resident database most up-to-date with log entries without requiring clients to block until the backup is updated. ([View Highlight](https://read.readwise.io/read/01hesjphm6ke6btzjrf91sev7r)) #Highlight #[[2023-11-09]]
- It is unfair to say that the in-memory database is the equivalent of an on-disk database with a huge page cache (see [“Buffer Management”](https://learning.oreilly.com/library/view/database-internals/9781492040330/ch01.html/ch05.html#buffer_pool)). Even though pages are *cached* in memory, serialization format and data layout incur additional overhead 开销 and do not permit the same degree of optimization that in-memory stores can achieve. ([View Highlight](https://read.readwise.io/read/01hesjq2wbg12hcz1vrgr3ewc3)) #Highlight #[[2023-11-09]]
- Disk-based databases use specialized storage structures, optimized for disk access. In memory, pointers can be followed comparatively quickly, and random memory access is significantly faster than the random disk access. Disk-based storage structures often have a form of wide and short trees (see [“Trees for Disk-Based Storage”](https://learning.oreilly.com/library/view/database-internals/9781492040330/ch01.html/ch02.html#trees_for_disk_based_storage)), while memory-based implementations can choose from a larger pool of data structures and perform optimizations that would otherwise be impossible or difficult to implement on disk [[GARCIAMOLINA92]](https://learning.oreilly.com/library/view/database-internals/9781492040330/ch01.html/app01.html#GARCIAMOLINA92). Similarly, handling variable-size data on disk requires special attention, while in memory it’s often a matter of referencing the value with a pointer. ([View Highlight](https://read.readwise.io/read/01hesjqp5gb4m9sdtj6g7e8dyw)) #Highlight #[[2023-11-09]]
- Since row-oriented stores are most useful in scenarios when we have to access data by row, storing entire rows together improves spatial locality ([View Highlight](https://read.readwise.io/read/01hesjrxwjvheaxmdtdxnh08af)) #Highlight #[[2023-11-09]]
- Because data on a persistent medium such as a disk is typically accessed block-wise (in other words, a minimal unit of disk access is a block), a single block will contain data for all columns. This is great for cases when we’d like to access an entire user record, but makes queries accessing individual fields of multiple user records (for example, queries fetching only the phone numbers) more expensive, since data for the other fields will be paged in as well. ([View Highlight](https://read.readwise.io/read/01hesjscdcgg99xpn79x2xd2c2)) #Highlight #[[2023-11-09]]
- Column-oriented stores are a good fit for analytical workloads that compute aggregates, such as finding trends, computing average values, etc. Processing complex aggregates can be used in cases when logical records have multiple fields, but some of them (in this case, price quotes) have different importance and are often consumed together. ([View Highlight](https://read.readwise.io/read/01hesjt035gqce2204k9p9hmtx)) #Highlight #[[2023-11-09]]
- During the last several years, likely due to a rising demand to run complex analytical queries over growing datasets, we’ve seen many new column-oriented file formats such as [Apache Parquet](https://databass.dev/links/112), [Apache ORC](https://databass.dev/links/113), [RCFile](https://databass.dev/links/114), as well as column-oriented stores, such as [Apache Kudu](https://databass.dev/links/115), [ClickHouse](https://databass.dev/links/116), and many others ([View Highlight](https://read.readwise.io/read/01hesjtvz69szpt157wgm968d3)) #Highlight #[[2023-11-09]]
- Column-oriented databases should not be mixed up with *wide column stores*, such as [BigTable](https://databass.dev/links/117) or [HBase](https://databass.dev/links/118), where data is represented as a multidimensional map, columns are grouped into *column* *families* (usually storing data of the same type), and inside each column family, data is stored row-wise. This layout is best for storing data retrieved by a key or a sequence of keys. ([View Highlight](https://read.readwise.io/read/01hesjw1zv4zqn18wtd4131kpm)) #Highlight #[[2023-11-09]]
- The primary goal of a database system is to store data and to allow quick access to it. ([View Highlight](https://read.readwise.io/read/01hesjy6sjvdr435pgpf3vy6a2)) #Highlight #[[2023-11-09]]
- Database systems do use files for storing the data, but instead of relying on filesystem hierarchies of directories and files for locating records, they compose files using implementation-specific formats. ([View Highlight](https://read.readwise.io/read/01hesjyj0d1hjvh7a9qw2zs5yc)) #Highlight #[[2023-11-09]]
- The main reasons to use specialized file organization over flat files are: ... Storage efficiency ... Access efficiency ... Update efficiency #Highlight #[[2023-11-09]]
- Database systems store *data records*, consisting of multiple fields, in tables, where each table is usually represented as a separate file. Each record in the table can be looked up using a *search key*. To locate a record, database systems use *indexes*: auxiliary data structures that allow it to efficiently locate data records without scanning an entire table on every access. Indexes are built using a subset of fields identifying the record. ([View Highlight](https://read.readwise.io/read/01hesjzfafwhghf0j975p77k5a)) #Highlight #[[2023-11-09]]
- A database system usually separates *data files* and *index files*: data files store data records, while index files store record metadata and use it to locate records in data files. ([View Highlight](https://read.readwise.io/read/01hesjzqm4hw8axcc0ys3svnxx)) #Highlight #[[2023-11-09]]
- ndex files are typically smaller than the data files. ([View Highlight](https://read.readwise.io/read/01hesk038kcx7rj6fkp5a95mv4)) #Highlight #[[2023-11-09]]
- Files are partitioned into *pages*, which typically have the size of a single or multiple disk blocks. Pages can be organized as sequences of records or as a *slotted pages* (see [“Slotted Pages”](https://learning.oreilly.com/library/view/database-internals/9781492040330/ch01.html/ch03.html#slotted_pages)). ([View Highlight](https://read.readwise.io/read/01hesk0bnaqgsn33622bqcnt6n)) #Highlight #[[2023-11-09]]
- Most modern storage systems *do not* delete data from pages explicitly. Instead, they use *deletion markers* (also called *tombstones*), which contain deletion metadata, such as a key and a timestamp. Space occupied by the records *shadowed* by their updates or deletion markers is reclaimed during garbage collection, which reads the pages, writes the live (i.e., nonshadowed) records to the new place, and discards the shadowed ones. ([View Highlight](https://read.readwise.io/read/01hesk0x49y4z6cvf920czfqh8)) #Highlight #[[2023-11-09]]
- Data files (sometimes called *primary files*) can be implemented as *index-organized tables* (IOT), *heap-organized tables* (heap files), or *hash-organized tables* (hashed files). ([View Highlight](https://read.readwise.io/read/01hesk1ycafgsz4b6mt2j2er35)) #Highlight #[[2023-11-09]]
- Records in heap files are not required to follow any particular order, and most of the time they are placed in a write order. This way, no additional work or file reorganization is required when new pages are appended. Heap files require additional index structures, pointing to the locations where data records are stored, to make them searchable. ([View Highlight](https://read.readwise.io/read/01hesk2dret1ns2jd88pf78t70)) #Highlight #[[2023-11-09]]
- In hashed files, records are stored in buckets, and the hash value of the key determines which bucket a record belongs to. Records in the bucket can be stored in append order or sorted by key to improve lookup speed. ([View Highlight](https://read.readwise.io/read/01hesk2m4cztq1pzdapj66dxff)) #Highlight #[[2023-11-09]]
- Index-organized tables (IOTs) store data records in the index itself. Since records are stored in key order, range scans in IOTs can be implemented by sequentially scanning its contents. ([View Highlight](https://read.readwise.io/read/01hesk2zy4kw4akk0f7yws8x6b)) #Highlight #[[2023-11-09]]
- An index on a *primary* (data) file is called the *primary index*. In most cases we can also assume that the primary index is built over a primary key or a set of keys identified as primary. All other indexes are called *secondary*. ([View Highlight](https://read.readwise.io/read/01hesk3ywkx3n1awzr5xhh6wpt)) #Highlight #[[2023-11-09]]
- If the order of data records follows the search key order, this index is called *clustered* (also known as clustering). Data records in the clustered case are usually stored in the same file or in a *clustered file*, where the key order is preserved. If the data is stored in a separate file, and its order does not follow the key order, the index is called *nonclustered* (sometimes called unclustered). ([View Highlight](https://read.readwise.io/read/01hesk5hmdaa3kjkyr23krk01b)) #Highlight #[[2023-11-09]]
- Index-organized tables store information in index order and are clustered by definition. Primary indexes are *most often* clustered. Secondary indexes are nonclustered by definition, since they’re used to facilitate 协助 access by keys other than the primary one. Clustered indexes can be both index-organized or have separate index and data files. ([View Highlight](https://read.readwise.io/read/01hesk6kd2wrhjcd76qy25w7pr)) #Highlight #[[2023-11-09]]
- There are different opinions in the database community on whether data records should be referenced directly (through file offset) or via the primary key index. ... By referencing data directly, we can reduce the number of disk seeks, but have to pay a cost of updating the pointers whenever the record is updated or relocated during a maintenance process. Using indirection in the form of a primary index allows us to reduce the cost of pointer updates, but has a higher cost on a read path. #Highlight #[[2023-11-09]]
- Updating just a couple of indexes might work if the workload mostly consists of reads, but this approach does not work well for write-heavy workloads with multiple indexes. To reduce the costs of pointer updates, instead of payload offsets, some implementations use primary keys for indirection. For example, MySQL InnoDB uses a primary index and performs two lookups: one in the secondary index, and one in a primary index when performing a query ([View Highlight](https://read.readwise.io/read/01hesk98ec310x8wfkfcrr1shn)) #Highlight #[[2023-11-09]]
- Storage structures have three common variables: they use *buffering* (or avoid using it), use *immutable* (or mutable) files, and store values *in order* (or out of order). ([View Highlight](https://read.readwise.io/read/01heskb9dergzxz49qat24zg3p)) #Highlight #[[2023-11-09]]
- Often the distinction between LSM and B-Trees is drawn as immutable against in-place update storage, but there are structures (for example, [“Bw-Trees”](https://learning.oreilly.com/library/view/database-internals/9781492040330/ch01.html/ch06.html#bw_tree)) that are inspired by B-Trees but are immutable. ([View Highlight](https://read.readwise.io/read/01heskcjcrjh7xcxe50qmetvv5)) #Highlight #[[2023-11-09]]