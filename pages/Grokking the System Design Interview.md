- [课程链接](https://designgurus.org/path-player?courseid=grokking-the-system-design-interview)
-
- ## System Design Guide
	- ### System Design Interviews: A step by step guide
	  collapsed:: true
		- **Step 1: Requirements clarifications**
			- It is always a good idea to ask questions about the exact scope of the problem we are trying to solve. Candidates who spend enough time to define the end goals of the system always have a better chance to be successful in the interview.
		- **Step 2: Back-of-the-envelope estimation**
			- It is always a good idea to estimate the scale of the system we’re going to design. This will also help later when we focus on scaling, partitioning, load balancing, and caching.
			- scale, storage, network bandwidth
		- **Step 3: System interface definition**
			- Define what APIs are expected from the system. This will establish the exact contract expected from the system and ensure if we haven’t gotten any requirements wrong.
		- **Step 4: Defining data model**
			- Defining the data model in the early part of the interview will clarify how data will flow between different system components.
			- Later, it will guide for data partitioning and management.
				- storage, transportation, encryption
		- **Step 5: High-level design**
			- Draw a block diagram with **5-6 boxes** representing the core components of our system. We should identify enough components that are needed to solve the actual problem from end to end.
		- **Step 6: Detailed design**
			- Dig deeper into two or three major components; the interviewer’s feedback should always guide us to what parts of the system need further discussion.
			- We should present different approaches, their pros and cons, and explain why we will prefer one approach over the other.
				- Remember, there is no single answer; the only important thing is to consider tradeoffs between different options while keeping system constraints in mind.
		- **Step 7: Identifying and resolving bottlenecks**
			- Try to discuss as many bottlenecks as possible and different approaches to mitigate them.
				- single point of failure
				- replicas of the data
				- enough copies of different services
				- monitoring the performance, get alerts whenever critical components fail or their performance degrades
		- Preparation and being organized during the interview are the keys to success in system design interviews.
	- ### Designing a URL Shortening service like TinyURL
	  collapsed:: true
		- **1. Why do we need URL shortening?**
		- **2. Requirements and Goals of the System**
			- You should always clarify requirements at the beginning of the interview. Be sure to ask questions to find the exact scope of the system that the interviewer has in mind.
			- Functional Requirements, Non-Functional Requirements, Extended Requirements
		- **3. Capacity Estimation and Constraints**
			- **Traffic estimates**, **Storage estimates**, **Bandwidth estimates**, **Memory estimates**
			- **High-level estimates** (Summary)
		- **4. System APIs**
			- Once we've finalized the requirements, it's always a good idea to define the system APIs. This should explicitly state what is expected from the system.
			- **How do we detect and prevent abuse?**
		- **5. Database Design**
			- Defining the DB schema in the early stages of the interview would help to understand the data flow among various components and later would guide towards data partitioning.
			- **Database Schema**
			- **What kind of database should we use?**
				- [SQL vs. NoSQL](https://designgurus.org/path-player?courseid=grokking-the-system-design-interview&unit=grokking-the-system-design-interview_1627054379423_8Unit)
		- **6. Basic System Design and Algorithm**
			- Hash or **Key Generation Service (KGS)**
		- **7. Data Partitioning and Replication**
			- **Range Based Partitioning** or **Hash-Based Partitioning**
				- [Consistent Hashing](https://designgurus.org/path-player?courseid=grokking-the-system-design-interview&unit=grokking-the-system-design-interview_1627054411532_11Unit)
		- **8. Cache**
			- **cache memory**, **cache eviction policy **
		- **9. Load Balancer (LB)**
		- **10. Purging or DB cleanup**
		- **11. Telemetry**
		- **12. Security and Permissions**
			- permission level (public/private)
- ## System Design Problems
	- ### Designing Pastebin
		- We can assume a 5:1 ratio between the read and write.
		- Users can upload maximum 10MB of data; commonly Pastebin like services are used to share source code, configs, or logs. Such texts are not huge, so let’s assume that each paste on average contains 10KB.
		- To keep some margin, we will assume a 70% capacity model (meaning we don’t want to use more than 70% of our total storage capacity at any point),
		- Following the 80-20 rule, meaning 20% of hot pastes generate 80% of traffic, we would like to cache these 20% pastes.
		- ‘ContentKey’ is a reference to an external object storing the contents of the paste
-