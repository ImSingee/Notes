file-path:: ../assets/raft-extended_1654411095297_0.pdf
file:: [raft-extended_1654411095297_0.pdf](../assets/raft-extended_1654411095297_0.pdf)
title:: Raft - In Search of an Understandable Consensus Algorithm (Extended Version)

- Raft 是一个为了管理副本日志（replicated log）的共识（consensus）算法
	- Raft 的结果与 (multi-)Paxos 相同并且更高效，但实现方法不尽相同
	- Raft 同时关注 understandable
	- Raft 的组成包括
	  hl-page:: 1
	  ls-type:: annotation
	  id:: 629c50c0-281d-4281-b796-286639681a46
		- 领导者选举 leader election
		- 日志同步 log replication
		- 安全性safety
	- Raft 执行了更强的一致性，以减少必须考虑的状态的数量
- 介绍
	- [[共识算法]] 允许一组机器作为一个共识组（consensus group）
		- 可以 survive the failures of some of its members
		- 常用于 build reliable large-scale software systems
	- Raft 的 novel feature（新奇的功能点）
		- Strong leader
			- 所有 log entry 仅会从 leader 流向其他机器
		- Leader Election
			- Raft 使用随机计时器 randomized timer 来选举 leader
		- Membership changes
			- Raft 在修改集群中的服务器时使用 joint consensus 算法
			- 这可以让配置修改过程中集群可以正常提供服务
- 复制状态机 replicated state machine
	- 被广泛用于分布式系统中实现 Fault Tolerance
	- ((6364d5c2-48c8-4123-b89d-26c7ed3bd39e))
	- 分布式算法的作用：保证集群中各个机器看到的 replicated log 一致(consistent)
	- 分布式算法的需求
		- 安全性
			- 在任何情况（不考虑拜占庭问题）下，保证返回数据的正确性
			- 异常情况可能为网络延迟、网络分区、丢包、网络包重复、网络包乱序
		- 可用性：只要集群中的大多数（过半）机器存活就可以正常提供服务；异常的机器恢复时可以自动恢复状态并重新加入集群
		- 不依赖时钟
		- 只要集群中的大部分（过半）机器响应了就可以回复给客户端，性能不受少量机器的影响
- Raft 共识算法
	- 实现
		- 首先选举 Leader
		- 由 Leader 进行完全的 replicated log 管理
			- Leader 从客户端接受 log entries
			- 将其同步到其他服务器
			- 在合适时机告知其他服务器将日志加入至自己的状态机
	- Raft 将共识问题分为
		- Leader 选举
		- 日志同步
		- 状态机安全性：日志一旦进入服务器的状态机就不会修改
	- Raft 基础
		- 一个 Raft 集群包括多台机器，可以容忍不过半的异常
			- 典型的 Raft 集群包括 5 台机器、可以容忍 2 台异常
		- 任何一刻一台服务器必处于 Leader、Follower、Candidate 中的一种状态
			- 在通常时刻（非选举时）存在 1 个 Leader、其他均为 Follower
		- Follower 是 passive 的：他们不自己发送请求，而是回复 Leader/Follower；对于客户端请求会将请求转发给 Leader
		- Raft 将时段用 term 做划分，一个 term 的时间是尽可能长的
			- term 是一个连续递增整数
			- 一个 Term 开始于选举（一个或多个 Candidate 试图称为 Leader）
				- 如果一个 Candidate 得到多数票，那么其称为 Leader
				- 如果存在平票，启动新一轮选举
				- 一个 Term 至多只存在一个 Leader
			- 任何一个服务器均存储当前的 term，在发送/响应任何请求时均会带上当前 term
				- 如果服务器发现了更新的 term，将自己本地存储的 term 更新
					- 特别的，如果 Leader 或 Candidate 发现了更新的 term，则其成为 Follower
				- 如果发现了旧的 term，直接 reject
		- Raft 服务期间通信使用 RPC，且仅需两个典型的 RPC
			- RequestVote 由  Candidate 发送
			- AppendEntries 由 Leader 发往 Follower
				- 空的 entries 列表被认为是心跳，如果一段时间内 Leader 并未向 Follower 发过消息则进行心跳
			- （非必要）（暂时未知）用于在服务器之间传输 snapshot
			- 如果在一段时间内服务期间 RPC 没有收到回复会超时重试
				- Server 向不同目标 Servers 发送消息时是平行发送的
		- Leader 选举
			- Raft 使用心跳来触发 Leader 重选举
			- 当 Server 启动时为 Follower
				- Server 会一直为 Follower，只要它收到过来自其他 Leader/Candidate 的 RPC
				- 如果超时没收到（election timeout），它认为当前没有 Leader 并且自己成为 Leader
			- 开始选举
				- Follower 增加自己本地的 term 值并转换为 Candidate 状态
				- 给自己先投一票，然后发送 RequestVote RPC 给集群中的其他机器
				- 会等待，直到下面三种情况之一发生
					- 赢得选举（获得过半投票）
					- 另一个服务器成为了 Leader
					- 再次超时而没有任何 Leader 被选举出
				- 当收到 RequestVote 时
					- 同一 term 只会为一个 Candidate 投票
					- 先到先得
						- 会有筛选机制，在后文
				- 赢得选举时会向其他所有服务器发送心跳（空 AppendEntries）
			- 防止短时间多台机器无限被多次选举：随机超时时间
				- 在 150-300ms 之间随机选择
					- 因此理论上同一时间只会有一个（或少量）服务器超时
					- 这一超时时间在每次选举前重置
			- Log Replication 日志副本
				- 客户端向 Leader 请求时，Leader 将日志记录到本地并发送 AppendEntries 到其他服务器
					- 当 entry 被安全 replicated，Leader 将日志加入至其状态机并将结果返回给客户端
						- committed = entry 被安全 replicated
						- Raft 保证一个 committed 的日志会最终被应用于所有状态机
						- 当 entry 被大多服务器接受时，其状态为 committed
							- 一个 entry 被 committed，则其之前的所有 entry 都已经被 committed 了（包括被其他 Leader 创建的）
							- Leader 会记录最后 committed 的日志 index，并在后续 AppendEntries 中发送
							- Follower 发现 log entry 被 committed 了会将其应用至本地状态机
					- 如果 AppendEntries 无法发送到指定服务器，会**无限重试**直至成功（即使已经返回给客户端结果了）
				- 日志 = 日志内容 + 当前 term + index
					- 如果两个 entry 拥有同样的 term+index 则其内容一致
					- 如果两个 entry 拥有同样的 term+index 则其之前的所有内容也一致
				- 可能导致不一致！
					- Leader 通过强制要求 Follower 必须是自己的日志副本来解决不一致
						- 对于不一致的会被 Leader 的覆盖
						- 安全性在后文阐述
					- Leader 会记录所有 Follower 的 nextIndex，并在 AppendEntries 中发送
						- Follower 处理 AppendEntries 时会做一致性检查，如果发现不一致会报错
					- 当 Leader 成为 Leader 时
						- 初始化所有的 nextIndex 为自己的
						- 尝试向所有 Follower 发送 AppendEntries
							- 如果被拒绝（未通过一致性验证），index-1 重发
							- 重复直至一致
							- 最终时 Leader 会为 Follower 的副本（并在 term 的剩余时间内持续为副本）
							-
						-
	-