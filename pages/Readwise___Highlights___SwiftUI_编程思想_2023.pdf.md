title:: Readwise/Highlights/SwiftUI_编程思想_2023.pdf
author:: [[]]
full-title:: SwiftUI_编程思想_2023.pdf
category:: #books
- Text 的宽度可能介于 0 到它的理想宽度之间，但是绝对不可能 超过理想宽度 (Page 78) #Highlight #[[2023-09-05]]
- HStack 根据⼦视图的灵活性从低到⾼进⾏排序。它会跟踪所有的剩余⼦视 图和可⽤的剩余宽度。 → 只要还有剩余的⼦视图，HStack 就会把剩余的宽度除以⼦视图的数量，然 后把结果作为建议宽度提供给这个⼦视图。 (Page 78) #Highlight #[[2023-09-05]]
- 使⽤ .layoutPriority 修饰器给 Text 设定⼀个布局优先级 (Page 79) #Highlight #[[2023-09-05]]
- 通过向每个⼦视图提供 0xproposedHeight 和 .in!nityxproposedHeight 作 为建议尺⼨，来确定每个⼦视图的灵活性。这个向⼦视图提议多个尺⼨的过 程也被称为探测 (probing)。灵活性被定义为两个结果宽度的差值 (Page 79) #Highlight #[[2023-09-05]]
- 通过将实现了 sizeThatFits ⽅法的⾃定义形状放⼊到堆栈中，并记录建议尺⼨和报告尺⼨，⾄ 少可以对布局⾏为进⾏部分验证 (Page 80) #Highlight #[[2023-09-05]]
- 乍⼀看，ZStack 似乎做的事情和 overlay 或者 background 是⼀样的，但是实际 上它们的⾏为不尽相同。如上所述，overlay 和 background 使⽤主要⼦视图的 尺⼨，并把次要⼦视图的尺⼨丢弃掉。当使⽤ ZStack 时，它的所有⼦视图的 frame 将组合起来，进⾏并集 (union) 操作，并依此计算 ZStack ⾃身的尺⼨ (Page 80) #Highlight #[[2023-09-05]]
- 滚动视图本身，在滚动轴的⽅向上会接受⽗视图所提供的建议尺⼨；在另⼀个轴 上，则使⽤它的内容的尺⼨。⽐如，如果我们把⼀个垂直的滚动视图作为根视图 的话，它的⾼度就是会整个安全区域，宽度则取决于滚动内容。 (Page 81) #Highlight #[[2023-09-05]]
- 在滚动⽅向上，滚动视图本质上具有⽆限的空间，它的内容在这个轴上也可以⽆ 限增⻓。因此，滚动视图在它的滚动轴上将使⽤ nil 作为建议尺⼨，在另外的轴 上则将滚动视图⾃身所收到的尺⼨不加修改地提供给内容视图。 (Page 81) #Highlight #[[2023-09-05]]
- 默认情况下，当我们为滚动视图的内容设定多个视图时 (就像我们上⾯做的这 样)，不管滚动⽅向如何，这些⼦视图都会被放在⼀个隐式的 VStack 中 (Page 82) #Highlight #[[2023-09-05]]
- 当滚动视图中存在⽂本时，有时候⽂本会指定换⾏，这样⽂本的宽度就有可能⽐ 收到的建议宽度要窄⼀些。如果滚动视图中没有其他的⼦视图将被建议的宽度接 受为⾃⼰的宽度时，就可能会导致滚动视图的宽度要⽐建议宽度⼩⼀些的情况。 想要修复这个问题，我们可以向 Text 添加 .frame(maxWidth: .in!nity)。对于 Text 之外那些不⼀定要接受建议宽度的其他视图，也可以同样处理。 (Page 82) #Highlight #[[2023-09-05]]
- SwiftUI 中内置 的形状的理想尺⼨都是 10⨉10。这是由于 ProposedViewSize 上 .replacingUnspeci!edDimensions(by:) 的默认参数是10x10 (Page 82) #Highlight #[[2023-09-05]]
- 和其他 SwiftUI 的容器视图相⽐，⼏何阅读器是⾮常特殊的存在，它不提供对⻬ 参数，在默认情况下它会将⼦视图放置在顶边和前边 (top-leading) 位置 —— ⽽ 除了 ScrollView 的其他所有容器视图默认会使⽤居中对⻬ (Page 83) #Highlight #[[2023-09-05]]