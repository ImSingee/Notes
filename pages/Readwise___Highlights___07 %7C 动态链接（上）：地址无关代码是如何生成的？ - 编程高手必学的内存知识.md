title:: Readwise/Highlights/07 | 动态链接（上）：地址无关代码是如何生成的？ - 编程高手必学的内存知识
author:: [[海纳]]
full-title:: 07 | 动态链接（上）：地址无关代码是如何生成的？ - 编程高手必学的内存知识
category:: #articles
url:: https://time.geekbang.org/column/article/437653

- 其中 LIBRARY_PATH 是由链接器来使用的，一般系统默认是 gnu ld。对于大部分开发者来讲，如果 LIBRARY_PATH 没有设置好，在使用 gcc 或者 clang 这些编译器（其实它们都调用了 ld 这个链接器，真正做事情的是 ld）的时候，会碰到类似/usr/bin/ld: cannot find -lfoo的错误。LIBRARY_PATH 的一个等价的选项就是上文讲的 -L 指定路径的选项。
  而另一个 LD_LIBRARY_PATH 的环境变量是由动态链接器来使用的，即我们通过 ldd 看到的 ld-linux-x86-64.so.2 这个库。动态链接器的知识我们会在下一节课中详细展开。 #Highlight #[[2023-05-07]]
- LIBRARY_PATH 的使用时机是链接器在做链接的时候，LD_LIBRARY_PATH 的使用时机是在程序运行时。 #Highlight #[[2023-05-07]]
- 动态库的数据段和代码段是靠在一起的，它并没有和可执行程序的数据段，代码段分别合并，这是与静态链接不同的地方 #Highlight #[[2023-05-07]]
- 同一个动态库文件在两个进程中的虚拟地址并不相同 #Highlight #[[2023-05-07]]
- Rss 的含义是当前段实际加载到物理内存中的大小，Pss 指的是进程按比例分配当前段所占物理内存的大小。 #Highlight #[[2023-05-07]]
- 由于多个进程共享了动态库，所以 Pss 的计算方式应该是 Rss 值除以共享进程数 #Highlight #[[2023-05-07]]
- 正是虚拟地址技术让我们在进程间共享动态库变得容易 #Highlight #[[2023-05-07]]
- 我们可以引入一个固定地址，让引用者与这个固定地址之间的相对偏移是固定的，然后这个地址处再填入 foo 函数真正的地址。当然，这个地方必然位于数据段中，是每个进程私有的，这样才能做到在不同的进程里，可以访问不同的虚拟地址。这个新引入的固定地址就是全局偏移表 (Global Offset Table, GOT)。 #Highlight #[[2023-05-07]]
- 32 位系统是通过一个 call stub 来获取的 pc 的值。因为 call 指令本身会做的一个操作是将 return address 压栈，而在 __x86.get_pc_thunk.bx 这个 stub 里边，则将当前栈顶的值 (%esp) 取出来放到 %ebx 寄存器中，那么此时 %ebx 里存放的就是 ret 之后的 pc 的值了。这个设计利用了 call 指令的会将下一条指令地址压栈的思路，非常巧妙的获取了 pc 的值，还是很有意思的。 #Highlight #[[2023-05-07]]
- GOT 表的相对偏移在同一个 so 中肯定是不变的 #Highlight #[[2023-05-07]]
- 每个进程都有自己的私有 GOT 段，GOT 中记录了当前的 so 文件所引用的所有外部符号。这些外部符号都需要进行解析和重定位。这个工作由 loader 负责，其为符号分配并记录地址，然后将这些地址回写进 GOT 表。 #Highlight #[[2023-05-07]]
- 地址无关的代码除了可以在 so 中使用，同样可以在可执行文件中使用，可以通过 -pie 选项使得 gcc 编译地址无关的可执行文件。地址文件的可执行文件可以被加载到内存的任意位置执行，这会使得缓冲区溢出的难度增加（你可以结合第 4 节课思考一下原因），但代价是通过 GOT 访问地址会多一次访存，性能会下降。 #Highlight #[[2023-05-07]]