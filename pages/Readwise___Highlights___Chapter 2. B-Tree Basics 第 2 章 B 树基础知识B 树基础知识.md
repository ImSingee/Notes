title:: Readwise/Highlights/Chapter 2. B-Tree Basics 第 2 章 B 树基础知识B 树基础知识
author:: [[O'Reilly Online Learning]]
full-title:: Chapter 2. B-Tree Basics 第 2 章 B 树基础知识B 树基础知识
category:: #articles
url:: https://learning.oreilly.com/library/view/database-internals/9781492040330/ch02.html

- In the previous chapter, we separated storage structures in two groups: *mutable* and *immutable* ones, and identified immutability as one of the core concepts influencing their design and implementation. Most of the mutable storage structures use an *in-place update* mechanism. During insert, delete, or update operations, data records are updated directly in their locations in the target file. ([View Highlight](https://read.readwise.io/read/01hf3cdz633gxn6xfjr8j6emhy)) #Highlight #[[2023-11-13]]
- Storage engines often allow multiple versions of the same data record to be present in the database; for example, when using multiversion concurrency control (see [“Multiversion Concurrency Control”](https://learning.oreilly.com/library/view/database-internals/9781492040330/ch02.html/ch05.html#mvcc)) or slotted page organization (see [“Slotted Pages”](https://learning.oreilly.com/library/view/database-internals/9781492040330/ch02.html/ch03.html#slotted_pages)). ([View Highlight](https://read.readwise.io/read/01hf3cec0ze3b0ehbqk77v4f5m)) #Highlight #[[2023-11-13]]
- even though it’s somewhat unlikely that all the items end up on one side of the tree, at least some of them certainly will, which will significantly slow down searches. ([View Highlight](https://read.readwise.io/read/01hf3ch56ahs92f09pxsd5jx8v)) #Highlight #[[2023-11-13]]
- The *balanced* tree is defined as one that has a height of `log2 N`, where `N` is the total number of items in the tree, and the difference in height between the two subtrees is not greater than one ([View Highlight](https://read.readwise.io/read/01hf3chjxxeb6wn7gymwtvka6y)) #Highlight #[[2023-11-13]]
- Without balancing, we lose performance benefits of the binary search tree structure, and allow insertions and deletions order to determine tree shape. ([View Highlight](https://read.readwise.io/read/01hf3chs4y993f2fx891zqfmj0)) #Highlight #[[2023-11-13]]
- In the balanced tree, following the left or right node pointer reduces the search space in half on average, so lookup complexity is logarithmic: `O(log2 N)`. If the tree is not balanced, worst-case complexity goes up to `O(N)`, since we might end up in the situation where all elements end up on one side of the tree. ([View Highlight](https://read.readwise.io/read/01hf3cj87s98740mmdfzd2dww1)) #Highlight #[[2023-11-13]]
- Balancing is done by reorganizing nodes in a way that minimizes tree height and keeps the number of nodes on each side within bounds. ([View Highlight](https://read.readwise.io/read/01hf3ck2zr0z83bbeqz4tkyk17)) #Highlight #[[2023-11-13]]
- One of the ways to keep the tree balanced is to perform a rotation step after nodes are added or removed. ([View Highlight](https://read.readwise.io/read/01hf3ckgsjvr7qgze6a9g30gys)) #Highlight #[[2023-11-13]]
- due to low *fanout* (fanout is the maximum allowed number of children per node), we have to perform balancing, relocate nodes, and update pointers rather frequently. ([View Highlight](https://read.readwise.io/read/01hf3cn44dna3ewsfdyz2zd6c9)) #Highlight #[[2023-11-13]]
- Increased maintenance costs make BSTs impractical as on-disk data structures ([View Highlight](https://read.readwise.io/read/01hf3cn7gk9t03ema5erf4tgz3)) #Highlight #[[2023-11-13]]
- 2-3-Trees and other low-fanout trees have a similar limitation: while they are useful as in-memory data structures, small node size makes them impractical for external storage ([View Highlight](https://read.readwise.io/read/01hf3crepahesq6qv2zxd177hz)) #Highlight #[[2023-11-13]]
- a version of the tree that would be better suited for disk implementation has to exhibit the following properties ... *High fanout* to improve locality of the neighboring keys. ... *Low height* to reduce the number of seeks during traversal. #Highlight #[[2023-11-13]]
- not every data structure that satisfies space and complexity requirements can be effectively used for on-disk storage. Data structures used in databases have to be adapted to account for persistent medium limitations. ([View Highlight](https://read.readwise.io/read/01hf3cteafsar83z3nb4mvjxpj)) #Highlight #[[2023-11-13]]
- On-disk data structures are often used when the amounts of data are so large that keeping an entire dataset in memory is impossible or not feasible. Only a fraction of the data can be *cached* in memory at any time, and the rest has to be stored on disk in a manner that allows efficiently accessing it. ([View Highlight](https://read.readwise.io/read/01hf3ctw81ax9wsasc7h8bz3eg)) #Highlight #[[2023-11-13]]
- On spinning disks, *seeks* increase costs of random reads because they require disk rotation and mechanical head movements to position the read/write head to the desired location. However, once the expensive part is done, reading or writing contiguous bytes (i.e., sequential operations) is *relatively* cheap. ([View Highlight](https://read.readwise.io/read/01hf3cvpg1pm9n7b1t9a2q2wdh)) #Highlight #[[2023-11-13]]
- The smallest transfer unit of a spinning drive is a *sector*, so when some operation is performed, at least an entire sector can be read or written. Sector sizes typically range from 512 bytes to 4 Kb. ([View Highlight](https://read.readwise.io/read/01hf3cvzrtmhb6s0xt53ygxb4v)) #Highlight #[[2023-11-13]]
- Head positioning is the most expensive part of an operation on the HDD. This is one of the reasons we often hear about the positive effects of *sequential* I/O: reading and writing contiguous memory segments 客群  客群  客群 from disk. ([View Highlight](https://read.readwise.io/read/01hf3cwbnj0qjg26jw98pp09yb)) #Highlight #[[2023-11-13]]
- Solid state drives (SSDs) do not have moving parts: there’s no disk that spins, or head that has to be positioned for the read. A typical SSD is built of *memory cells*, connected into *strings* (typically 32 to 64 cells per string), strings are combined into *arrays*, arrays are combined into *pages*, and pages are combined into *blocks* ([View Highlight](https://read.readwise.io/read/01hf3cwwts8vgrxd4p6rerjhpp)) #Highlight #[[2023-11-13]]
- Depending on the exact technology used, a cell can hold one or multiple bits of data. Pages vary in size between devices, but typically their sizes range from 2 to 16 Kb. Blocks typically contain 64 to 512 pages. Blocks are organized into planes and, finally, planes are placed on a *die*. SSDs can have one or more dies ([View Highlight](https://read.readwise.io/read/01hf3cxgc9b895kcgdbs6qwvf0)) #Highlight #[[2023-11-13]]
- ![dbin 0205](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492040330/files/assets/dbin_0205.png)Figure 2-5. SSD organization schematics ([View Highlight](https://read.readwise.io/read/01hf3czkxr6vr1srbzg5eb0k81)) #Highlight #[[2023-11-13]]
- The smallest unit that can be written (programmed) or read is a page. However, we can only make changes to the empty memory cells (i.e., to ones that have been erased before the write). The smallest erase entity is not a page, but a block that holds multiple pages, which is why it is often called an *erase block*. Pages in an empty block have to be written sequentially. ([View Highlight](https://read.readwise.io/read/01hf3cz1q41tsgdpfmnh4hvzd9)) #Highlight #[[2023-11-13]]
- The part of a flash memory controller responsible for mapping page IDs to their physical locations, tracking empty, written, and discarded pages, is called the Flash Translation Layer (FTL) ([View Highlight](https://read.readwise.io/read/01hf3czzrazjk8z36mgncqnx11)) #Highlight #[[2023-11-13]]
- In SSDs, we don’t have a strong emphasis on random versus sequential I/O, as in HDDs, because the difference in latencies between random and sequential reads is not as large. There is *still* some difference caused by prefetching, reading contiguous pages, and internal parallelism ([View Highlight](https://read.readwise.io/read/01hf3d0zezbqe06pgsfws2btws)) #Highlight #[[2023-11-13]]
- Even though garbage collection is usually a background operation, its effects may negatively impact write performance, especially in cases of random and unaligned write workloads. ([View Highlight](https://read.readwise.io/read/01hf3d14tbyjbb1yc44728pdbk)) #Highlight #[[2023-11-13]]
- Writing only full blocks, and combining subsequent writes to the same block, can help to reduce the number of required I/O operations ([View Highlight](https://read.readwise.io/read/01hf3d1da39a841d2mhbyf28tj)) #Highlight #[[2023-11-13]]
- B-Trees build upon the foundation of balanced search trees and are different in that they have higher fanout (have more child nodes) and smaller height. ([View Highlight](https://read.readwise.io/read/01hf3d2k7fn9jbncecb1tchn5g)) #Highlight #[[2023-11-13]]
- B-Trees are *sorted*: keys inside the B-Tree nodes are stored in order. Because of that, to locate a searched key, we can use an algorithm like binary search. ([View Highlight](https://read.readwise.io/read/01hf3d5fmgjdxmbbh1pp54s7r0)) #Highlight #[[2023-11-13]]
- B-Trees consist of multiple nodes. Each node holds up to `N` keys and `N + 1` pointers to the child nodes. ([View Highlight](https://read.readwise.io/read/01hf3d6x13w57yms5t5yc79hzt)) #Highlight #[[2023-11-13]]
- The relation between the node capacity and the number of keys it actually holds is called *occupancy*. ([View Highlight](https://read.readwise.io/read/01hf3d7e3exx9hbqza8d9qwgdv)) #Highlight #[[2023-11-13]]
- B-Trees allow storing values on any level: in root, internal, and leaf nodes. B+-Trees store values *only* in leaf nodes. Internal nodes store only *separator keys* used to guide the search algorithm to the associated value stored on the leaf level. ([View Highlight](https://read.readwise.io/read/01hf3d96zdyq2r4sy73z79mpgx)) #Highlight #[[2023-11-13]]
- Since values in B+-Trees are stored only on the leaf level, all operations (inserting, updating, removing, and retrieving data records) affect only leaf nodes and propagate to higher levels only during splits and merges. ([View Highlight](https://read.readwise.io/read/01hf3d9dnjd45y7jf5ea2tk8f5)) #Highlight #[[2023-11-13]]
- B+-Trees became widespread, and we refer to them as B-Trees, similar to other literature ([View Highlight](https://read.readwise.io/read/01hf3d9xc7svzv0kczdq92gyds)) #Highlight #[[2023-11-13]]