- [link](https://github.com/Vonng/ddia/blob/master/ch4.md)
-
- 从内存中表示到字节序列的转换称为 **编码（Encoding）** （也称为 **序列化（serialization）** 或 **编组（marshalling）**），反过来称为 **解码（Decoding）**（**解析（Parsing）**，**反序列化（deserialization）**，**反编组 (unmarshalling）**）。
-
### 语言特定的格式
	- 许多编程语言都内建了将内存对象编码为字节序列的支持
		- Java 有 `java.io.Serializable`
		- Ruby 有 `Marshal`
		- Python 有 `pickle`
	- 这些编码库非常方便。但是有一些深层次的问题
		- 通常与特定的编程语言深度绑定，其他语言很难读取这种数据
		- 为了恢复相同对象类型的数据，解码过程需要 **实例化任意类** 的能力，这通常是安全问题的一个来源
		- 在这些库中，数据版本控制通常是事后才考虑的。因为它们旨在快速简便地对数据进行编码，所以往往忽略了前向后向兼容性带来的麻烦问题。
		- 效率（编码或解码所花费的 CPU 时间，以及编码结构的大小）往往也是事后才考虑的。
	- 除非临时使用，采用语言内置编码通常是一个**坏主意**。\
### JSON、XML和二进制变体
	- JSON，XML 和 CSV 属于文本格式，因此具有人类可读性（尽管它们的语法是一个热门争议话题）
		- **数字（numbers）** 编码有很多模糊之处。在 XML 和 CSV 中，无法区分数字和碰巧由数字组成的字符串（除了引用外部模式）。 JSON 虽然区分字符串与数字，但并不区分整数和浮点数，并且不能指定精度。
		- JSON 和 XML 对 Unicode 字符串（即人类可读的文本）有很好的支持，但是它们不支持二进制数据（即不带 **字符编码（character encoding）** 的字节序列）。
			- 人们通过使用 Base64 将二进制数据编码为文本来绕过此限制。其特有的模式标识着这个值应当被解释为 Base64 编码的二进制数据。这种方案虽然管用，但比较 Hacky，并且会增加三分之一的数据大小。
		- 模式