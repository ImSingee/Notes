title:: Readwise/Highlights/26 | 使用阻塞i/O和线程模型：换一种轻量的方式-极客时间 (65)
author:: [[time.geekbang.org]]
full-title:: 26 | 使用阻塞i/O和线程模型：换一种轻量的方式-极客时间
category:: #articles
url:: https://time.geekbang.org/column/article/145464

- 除了动手实践外，看源码也是一个快速提高自己的途径。俗话说，熟读唐诗三百首，不会作诗也会吟。源码读懂了，就可以帮助你大幅度理解原理，技巧也会得到提升。在网络编程这块，我推荐你看 libevent、ACE 或者 Asio 的源代码。libevent 是一个轻量级的基于 event 回调机制的网络编程库，可以支持 Linux、Solaris、Windows 等系统，它本身是用 C 语言写的，代码量不是很多，比较适合入门级的阅读。Asio 是 boost 里的网络编程库，是用 C++ 语言写的。里面用了很多 boost 的数据结构和技巧，包括大量模板的使用，有一定的语言难度，如果你对自己的 C++ 能力比较自信，可以试着去读一读。boost 库本身也已经成为 C++ 的标准库，其设计和实现也可以说是一个学习的样板。ACE 是老牌的 C++ 网络编程库，我读书那会非常流行，也基于 ACE 写过很多网络程序。很多设计模式如 reactor、proactor 都是 ACE 首次提出并倡导的。当然也有很多网络编程的大佬们觉得 ACE 有点过于设计了，搞得太复杂，没必要。这个我觉得见仁见智吧，有些好的思想可以拿来用，觉得不合适该抛弃就抛弃。ACE 强在设计模式和抽象，如果对设计模式感兴趣，可以花一些时间学习下 ACE 的设计。 #Highlight #[[2022-06-15]]
- 因为同步调用、异步调用的说法，是对于获取数据的过程而言的，前面几种最后获取数据的 read 操作调用，都是同步的，在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，这个过程是在 read 函数中同步进行的，如果内核实现的拷贝效率很差，read 调用就会在这个同步过程中消耗比较长的时间。 #Highlight #[[2022-06-15]]
- 在网络中，经常会发生报文经过一段时间才能到达目的地的情况，产生的原因是多种多样的，如路由器重启，链路突然出现故障等。如果迷走报文到达时，发现 TCP 连接四元组（源 IP，源端口，目的 IP，目的端口）所代表的连接不复存在，那么很简单，这个报文自然丢弃。我们考虑这样一个场景，在原连接中断后，又重新创建了一个原连接的“化身”，说是化身其实是因为这个连接和原先的连接四元组完全相同，如果迷失报文经过一段时间也到达，那么这个报文会被误认为是连接“化身”的一个 TCP 分节，这样就会对 TCP 通信产生影响。 #Highlight #[[2022-06-15]]
- TCP 协议也在与时俱进，RFC 1323 中实现了 TCP 拓展规范，以便保证 TCP 的高可用，并引入了新的 TCP 选项，两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。由于引入了时间戳，我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。 #Highlight #[[2022-06-15]]
- aio 系列函数是由 POSIX 定义的异步操作接口，可惜的是，Linux 下的 aio 操作，不是真正的操作系统级别支持的，它只是由 GNU libc 库函数在用户空间借由 pthread 方式实现的，而且仅仅针对磁盘类 I/O，套接字 I/O 不支持。 #Highlight #[[2022-06-15]]