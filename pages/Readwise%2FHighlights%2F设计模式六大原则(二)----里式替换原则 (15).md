title:: Readwise/Highlights/设计模式六大原则(二)----里式替换原则 (15)
author:: [[juejin.cn]]
full-title:: 设计模式六大原则(二)----里式替换原则
category:: #articles
url:: https://juejin.cn/post/6967281624044011551?cmdid=MITRR5R9NK0TFL

- 里式替换原则是用来帮助我们在继承关系中进行父子类的设计 #Highlight #[[2021-05-29]]
- 里式替换原则有两层定义: 定义1
  
  If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。 如果S是T的子类，则T的对象可以替换为S的对象，而不会破坏程序。
  
  定义2：
  
  Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。
  
  所有引用其父类对象方法的地方，都可以透明的替换为其子类对象 #Highlight #[[2021-05-29]]
- 应用程序中任何父类对象出现的地方，我们都可以用其子类的对象来替换，并且可以保证原有程序的逻辑行为和正确性 #Highlight #[[2021-05-29]]
- 共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能 #Highlight #[[2021-05-29]]
- 我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法 #Highlight #[[2021-05-29]]
- 不符合LSP的最常见的情况是，父类和子类都是可实例化的非抽象类，且父类的方法被子类重新定义，这一类的实现继承会造成父类和子类间的强耦合，也就是实际上并不相关的属性和方法牵强附会在一起，不利于程序扩展和维护。 #Highlight #[[2021-05-29]]
- 减少继承带来的缺点，增强程序的健壮性 #Highlight #[[2021-05-29]]
- 子类方法不能违背父类方法对输入输出异常的约定 #Highlight #[[2021-05-29]]
- 前置条件不能被加强 #Highlight #[[2021-05-29]]
- 后置条件不能被削弱 #Highlight #[[2021-05-29]]
- 不能违背对异常的约定 #Highlight #[[2021-05-29]]
- 子类方法不能违背父类方法定义的功能 #Highlight #[[2021-05-29]]
- 如何验证子类设计是否符合里氏替换原则其实有一个小技巧，那就是你可以使用父类的单测来运行子类的代码 #Highlight #[[2021-05-29]]
- 子类必须完全实现父类的抽象方法 #Highlight #[[2021-05-29]]
- 不仅仅不满足里氏替换原则，也不满足接口隔离原则 #Highlight #[[2021-05-29]]
- 接口隔离+委托 #Highlight #[[2021-05-29]]
- 里氏替换原则是实现开闭原则的重要方式之一 #Highlight #[[2021-05-29]]
- 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能 #Highlight #[[2021-05-29]]
- 对里氏替换原则的定义可以总结如下：
  
  子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
  子类中可以增加自己特有的方法
  当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
  当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等 #Highlight #[[2021-05-29]]
- 如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。 #Highlight #[[2021-05-29]]