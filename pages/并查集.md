- #Algorithm
-
- 并查集提供了一个结构，用于在 O(1) 时间内标记两个集合相交 (union)、查找两个集合是否相交 (isSameSet)
-
- ## 基本数据结构
	- 每个节点都有一条往上指的指针
	- 节点 a 往上找到的头节点，叫做 a 所在集合的**代表节点**
	- 查询 x 和 y 是否属于同一个集合，就是看看找到的代表节点是不是一个
	- 把x和y各自所在集合的所有点合并成一个集合，只需要小集合的代表点挂在大集合的代表点的下方即可
- ## 编码时的优化
	- 通过如下优化，来保证 union 和 isSameSet 方法的时间复杂度降为 O(1)
		- 节点向上找头节点的过程，将沿途的链「扁平化」
		- 小集合挂在大集合的下面
- ## 并查集的应用
	- 连通性的问题
	- 解决两大块区域的合并问题
	- 常用在图等领域中
- ## 实现
	- 题目：完善下面的结构
		- ```java
		  class UnionFind<V> {
		    // 利用所有的元素列表进行初始化
		    public UnionFind(List<V> values) {
		      // TODO
		    }
		  
		    // 判断元素 a 与 b 是否在同一集合内
		    public boolean isSameSet(V a, V b) {
		      // TODO
		    }
		  
		    // 记录元素 a 与 b 在同一集合内
		    public void union(V a, V b) {
		      // TODO
		    }
		  
		    // 返回不相交的集合数量
		    public int sets() {
		      // TODO
		    }
		  }
		  ```
	- 答案一（未进行任何额外优化）
		- ```java
		  public class UnionFind<V> {
		      private final Map<V, V> nodes;
		  
		      // 利用所有的元素列表进行初始化
		      public UnionFind(List<V> values) {
		        nodes = new HashMap<>(values.size());
		        for (V e : values) {
		          nodes.put(e, null);
		        }
		      }
		  
		      private V getFinalFather(V a) {
		        V parent;
		        while ((parent = nodes.get(a)) != null) {
		          a = parent;
		        }
		        return a;
		      }
		  
		      // 判断元素 a 与 b 是否在同一集合内
		      public boolean isSameSet(V a, V b) {
		        V aFinal = getFinalFather(a);
		        V bFinal = getFinalFather(b);
		  
		        return aFinal == bFinal;
		      }
		  
		      // 记录元素 a 与 b 在同一集合内
		      public void union(V a, V b) {
		        V aFinal = getFinalFather(a);
		        V bFinal = getFinalFather(b);
		  
		        if (aFinal != bFinal) {
		          nodes.put(aFinal, bFinal);
		        }
		      }
		  
		      // 返回不相交的集合数量
		      public int sets() {
		        int count = 0;
		        for (Map.Entry<V, V> entry : nodes.entrySet()) {
		          if (entry.getValue() == null) {
		            count++;
		          }
		        }
		        return count;
		      }
		  }
		  ```
		- [正确性验证](https://leetcode.com/submissions/detail/632969890/)
		- 问题一：如果 V 重写了 equals 可能会造成判断异常
		- 问题二：sets 方法的时间复杂度过高
		- 问题三：getFinalFather 方法的时间复杂度过高
	- 答案二（优化后）
		- ```java
		  public class UnionFind<V> {
		      private class Node {
		        final private V val;
		  
		        public Node(V v) {
		          val = v;
		        }
		  
		        public V get() {
		          return val;
		        }
		      }
		  
		      private final Map<V, Node> nodes;
		      private final Map<Node, Node> parents;
		      private final Map<Node, Integer> sizes;
		  
		      // 利用所有的元素列表进行初始化
		      public UnionFind(List<V> values) {
		        nodes = new HashMap<>(values.size());
		        parents = new HashMap<>(values.size());
		        sizes = new HashMap<>(values.size());
		  
		  
		        for (V e : values) {
		          Node node = new Node(e);
		          nodes.put(e, node);
		          parents.put(node, node);
		          sizes.put(node, 1);
		        }
		      }
		  
		      private Node getFinalFather(Node a) {
		        Stack<Node> paths = new Stack<>();
		        Node parent;
		        while (!(parent = parents.get(a)).equals(a)) { // 当自己是自己的父亲时，终止
		          paths.push(a);
		          a = parent;
		        }
		  
		        while (!paths.isEmpty()) { // 将沿途元素的 parent 设置为最终 parent
		          parents.put(paths.pop(), parent);
		        }
		  
		        return parent;
		      }
		  
		      // 判断元素 a 与 b 是否在同一集合内
		      public boolean isSameSet(V a, V b) {
		        Node aFinal = getFinalFather(nodes.get(a));
		        Node bFinal = getFinalFather(nodes.get(b));
		  
		        return aFinal == bFinal;
		      }
		  
		      // 记录元素 a 与 b 在同一集合内
		      public void union(V a, V b) {
		        Node aFinal = getFinalFather(nodes.get(a));
		        Node bFinal = getFinalFather(nodes.get(b));
		  
		        if (aFinal == bFinal) return;
		  
		        Node bigger = aFinal, smaller = bFinal;
		        int aSize = sizes.get(aFinal), bSize = sizes.get(bFinal);
		  
		        if (aSize < bSize) { // 交换 bigger&smaller
		          bigger = bFinal;
		          smaller = aFinal;
		        }
		  
		        // 将 smaller 挂在 bigger 上
		        parents.put(smaller, bigger);
		        sizes.put(bigger, aSize + bSize);
		        sizes.remove(smaller);
		      }
		  
		      // 返回不相交的集合数量
		      public int sets() {
		        return sizes.size();
		      }
		  }
		  ```
		- [正确性验证](https://leetcode.com/submissions/detail/632995588/)
		-
		-
	- [class14/Code05_UnionFind.java](https://github.com/singee-study/algorithm-java/blob/master/zuo-algorithm-2020/class14/Code05_UnionFind.java)
- ## 典型题目
	- [[省份数量]]
	- [[岛问题]]
	- [[岛屿数量 II]]
	- 岛问题 [[并行算法]]