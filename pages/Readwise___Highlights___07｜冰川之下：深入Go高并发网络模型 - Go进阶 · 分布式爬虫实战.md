title:: Readwise/Highlights/07｜冰川之下：深入Go高并发网络模型 - Go进阶 · 分布式爬虫实战
author:: [[郑建勋]]
full-title:: 07｜冰川之下：深入Go高并发网络模型 - Go进阶 · 分布式爬虫实战
category:: #articles
url:: https://time.geekbang.org/column/article/596287
- Go 语言在初始化时会启动一个特殊的线程来执行系统监控任务 sysmon。系统监控在一个独立的线程上运行，不用绑定逻辑处理器 P。系统监控每隔 10ms 会检测是否有准备就绪的网络协程，若有，就放置到全局队列中。 #Highlight #[[2023-04-18]]
- Go 运行时只会全局调用一次 netpollinit 函数。而我们之前看到的 conn.Read、conn.Write 等读取和写入函数底层都会调用 netpollopen 将对应 Socket 放入到 epoll 中进行监听。 #Highlight #[[2023-04-18]]
- 而 Go 语言中的协程栈大小默认为 2KB，并且是动态扩容的。因此在实践中，经常会看到成千上万的协程存在。 #Highlight #[[2023-04-18]]
- 线程的空间成本主要来自于线程的堆栈大小。线程的堆栈大小一般是在创建时指定的，为了避免出现栈溢出（Stack Overflow），默认的栈会相对较大（例如 2MB），这意味着每创建 1000 个线程就需要消耗 2GB 的虚拟内存，这大大限制了创建的线程的数量（虽然 64 位的虚拟内存地址空间已经让这种限制变得不太严重了 #Highlight #[[2023-04-18]]
- 如果两个线程位于不同的进程，进程之间的上下文切换还会因为内存地址空间的切换导致缓存失效，所以不同进程的切换要显著慢于同一进程中线程的切换（现代的 CPU 使用快速上下文切换技术解决了进程切换带来的缓存失效问题）。 #Highlight #[[2023-04-18]]
- 线程的时间成本主要来自于切换线程上下文时，用户态与内核态的切换、线程的调度、寄存器变量以及状态信息的存储。 #Highlight #[[2023-04-18]]
- 进程可以通过文件描述符找到对应的 Socket 结构。Socket 结构中存储了发送队列与接收队列，每一个队列中保存了结构 sk_buffer。sk_buff 是代表数据包的主要网络结构，但是 sk_buff 本身存储的是一个元数据，不保存任何数据包数据，所有数据都保存在相关的缓冲区中。 #Highlight #[[2023-04-18]]