title:: Readwise/Highlights/操作系统真相还原
author:: [[郑　钢]]
full-title:: 操作系统真相还原
category:: #books
- 编译器提供了一套库函数，库函数中又有封装的系统调用，这样的代码集合称之为运行库。C语言的运行库称为C运行库，就是所谓的CRT（C Runtime Library）。 #Highlight #[[2023-04-27]]
- 注意，很多读者都觉得段基址一定得是65536的倍数（16位段基址寄存器的容量），这个真的不用，段基址可以是任意的。这就是段可以重叠的原因 #Highlight #[[2023-04-27]]
- 只要程序分了段，把整个段平移到任何位置后，段内的地址相对于段基址是不变的，无论段基址是多少，只要给出段内偏移地址，CPU就能访问到正确的指令。于是加载用户程序时，只要将整个段的内容复制到新的位置，再将段基址寄存器中的地址改成该地址，程序便可准确无误地运行，因为程序中用的是段内偏移地址，相对于新的段基址，该偏移地址处的内存内容还是一样的 #Highlight #[[2023-04-27]]
- 程序不是一定要分段才能运行的，分段只是为了使程序更加优美 #Highlight #[[2023-04-27]]
- x86平台的处理器是必须要用分段机制访问内存的 #Highlight #[[2023-04-27]]
- 程序中段的类型可多了，用“readelf –e elf”命令便可以看到很多段的类型 #Highlight #[[2023-04-27]]
- 在保护模式下，有这样一个数据结构，它叫全局描述符表（Global Descriptor Table，GDT），这个表中的每一项称为段描述符 #Highlight #[[2023-04-27]]
- 在段描述符中有段的属性位，在以后的章节中可以看到，其实是有2个，一个是S字段，占1bit大小，另外一个是占4bit大小的TYPE字段，这两个字段配合在一起使用就能组合出各种属性，如只读、向下扩展、只执行等。 #Highlight #[[2023-04-27]]
- 操作系统在让CPU进入保护模式之前，首先要准备好GDT，也就是要设置好GDT的相关项，填写好段描述符。段描述符填写成什么样，段具备什么样的属性，这完全取决于操作系统了，在这里大家只要知道，段描述符中的S字段和TYPE字段负责该段的属性，也就是该属性与安全相关。 #Highlight #[[2023-04-27]]
- 因为栈指针在使用过程中指向的地址越来越低，所以初始化时一定得是栈段的最高地址 #Highlight #[[2023-04-27]]
- Section Headers：列出了程序中所有的section，这些section是gcc编译器帮忙划分的。
  •  Program Headers：列出了程序中的段，即segment，这是程序中section合并后的结果。 #Highlight #[[2023-04-27]]
- 程序中的段只是逻辑上的划分，用于不同数据的归类，但是可以用CPU中的段寄存器直接指向它们，然后用内存分段机制去访问程序中的段 #Highlight #[[2023-04-27]]
- 物理地址就是物理内存真正的地址，相当于内存中每个存储单元的门牌号，具有唯一性。不管在什么模式下，不管什么虚拟地址、线性地址，CPU最终都要以物理地址去访问内存，只有物理地址才是内存访问的终点站。 #Highlight #[[2023-04-27]]
- 在实模式下，“段基址+段内偏移地址”经过段部件的处理，直接输出的就是物理地址，CPU可以直接用此地址访问内存。 #Highlight #[[2023-04-27]]
- 在保护模式下，“段基址+段内偏移地址”称为线性地址，不过，此时的段基址已经不再是真正的地址了，而是一个称为选择子的东西。它本质是个索引，类似于数组下标，通过这个索引便能在GDT中找到相应的段描述符，在该描述符中记录了该段的起始、大小等信息，这样便得到了段基址。若没有开启地址分页功能，此线性地址就被当作物理地址来用，可直接访问内存。若开启了分页功能，此线性地址又多了一个名字，就是虚拟地址（虚拟地址、线性地址在分页机制下都是一回事）。虚拟地址要经过CPU页部件转换成具体的物理地址，这样CPU才能将其送上地址总线去访问内存。 #Highlight #[[2023-04-27]]
- 无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址，这是程序员可见的地址 #Highlight #[[2023-04-27]]
- ES——附加段寄存器（Extra Segment Register），其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他sreg那样固定，可以额外做他用 #Highlight #[[2023-04-27]]
- 32位CPU有两种不同的工作模式：实模式和保护模式。
  每种模式下，段寄存器中值的意义是不同的，但不管其为何值，在段寄存器中所表达的都是指向的段在哪里。 #Highlight #[[2023-04-27]]
- 在实模式下，CS、DS、ES、SS中的值为段基址，是具体的物理地址 #Highlight #[[2023-04-27]]
- 在保护模式下，装入段寄存器的不再是段地址，而是“段选择子”（Selector），当然，选择子也是数值，其依然为16位宽度。 #Highlight #[[2023-04-27]]
- Linux下的可执行程序格式是elf，也就是 “Executable and Linking Format” #Highlight #[[2023-04-27]]
- elf文件头，里面有节（section）信息、段（segment）信息、程序入口（entry_point）、哪个段由哪些节组成等信息 #Highlight #[[2023-04-27]]
- Windows下的可执行程序是PE格式（portable executable，可移植的可执行文件） #Highlight #[[2023-04-27]]
- 栈由于是向下生长的，堆栈框架就是把esp指针提前加一个数，原esp指针到新esp指针之间的栈空间用来存储局部变量 #Highlight #[[2023-04-27]]
- 脚本中的代码在脚本解释器看来和字符串无异。也就是说，脚本中的代码从来没真正上过CPU去执行，CPU的cs：ip寄存器从来没指向过它们 #Highlight #[[2023-04-27]]
- 这些脚本代码看似在按照开发人员的逻辑执行，本质上是脚本解释器在时时分析这个脚本，动态根据关键字和语法来做出相应的行为 #Highlight #[[2023-04-27]]
- 小端字节序是数值的低字节放在内存的低地址处，数值的高字节放在内存的高地址 #Highlight #[[2023-04-28]]
- 大端字节序是数值的低字节放在内存的高地址处，数值的高字节放在内存的低地址 #Highlight #[[2023-04-28]]
- bochs模拟的x86体系结构虚拟机是小端字节序，即数值上的低字节0x78在物理内存上的低地址，其他数值也依次符合小端字节序 #Highlight #[[2023-04-28]]
- 小端：因为低位在低字节，强制转换数据型时不需要再调整字节了 #Highlight #[[2023-04-28]]
- 大端：有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一字节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负 #Highlight #[[2023-04-28]]
- 编译器的转换原则是强制转换到低精度类型，丢弃数值的高字节位，只保留数值的低字节 #Highlight #[[2023-04-28]]
- 对于人类来说，还是大端看上去顺眼，毕竟咱们存储0x12345678到内存时，它在内存中的存储顺序也是0x12345678，而不是0x78563412，这样看上去才直观 #Highlight #[[2023-04-28]]
- 小端字节序：x86 #Highlight #[[2023-04-28]]
- ARM体系的CPU则大小端字节序通吃，具体用哪类字节序由硬件选择 #Highlight #[[2023-04-28]]
- 字节序不仅是在CPU访问内存中的概念，而且也包括在文件存储和网络传输中。bmp格式的图片就属于小端字节序，而jpeg格式的图片则为大端字节序，这没什么可说的，采用什么序列完全是开发者设计产品时的需要。 #Highlight #[[2023-04-28]]
- 网络字节序就是大端字节序，所以在x86架构上的程序在发送网络数据时，要转换字节顺序 #Highlight #[[2023-04-28]]
- BIOS和DOS都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的。它们都是通过软中断指令int 中断号来调用的 #Highlight #[[2023-04-28]]
- 中断向量表中的每个中断向量大小是4字节。这4字节描述了一个中断处理例程（程序）的段基址和段内偏移地址。因为中断向量表的长度为1024字节，故该表最多容纳256个中断向量处理程序。计算机启动之初，中断向量表中的中断例程是由BIOS建立的，它从物理内存地址0x0000处初始化并在中断向量表中添加各种处理例程 #Highlight #[[2023-04-28]]
- 不通过BIOS调用也是可以访问硬件 #Highlight #[[2023-04-28]]
- 操作硬件无非是通过in/out指令来读写外设的端口，BIOS中断程序处理是用来操作硬件的，故该处理程序中一定到处都是in/out指令 #Highlight #[[2023-04-28]]
- 每个外设，包括显卡、键盘、各种控制器等，都有自己的内存（主板也有自己的内存，BIOS就存放在里面），不过这种内存都是只读存储器ROM #Highlight #[[2023-04-28]]
- 硬件自己的功能调用例程及初始化代码就存放在这ROM中。根据规范，第1个内存单元的内容是0x55，第2个存储单元是0xAA，第3个存储单位是该rom中以512字节为单位的代码长度。从第4个存储单元起就是实际代码了，直到第3个存储单元所示的长度为止 #Highlight #[[2023-04-28]]
- 访问外设有两种方式。
  （1）内存映射：通过地址总线将外设自己的内存映射到某个内存区域（并不是映射到主板上插的内存条中）。
  （2）端口操作：外设都有自己的控制器，控制器上有寄存器，这些寄存器就是所谓的端口，通过in/out指令读写端口来访问硬件的内存。 #Highlight #[[2023-04-28]]
- 从内存的物理地址0xA0000开始到0xFFFFF这部分内存中，一部分是专门用来做映射的，如果硬件存在，硬件自己的ROM会被映射到这片内存中的某处 #Highlight #[[2023-04-28]]
- BIOS在运行期间会扫描0xC0000到0xE0000之间的内存，若在某个区域发现前两个字节是0x55和0xAA时，这意味着该区域对应的rom中有代码存在，再对该区域做累加和检查，若结果与第3个字节的值相符，说明代码无误，就从第4个字节进入。这时开始执行了硬件自带的例程以初始化硬件自身，最后，BIOS填写中断向量表中相关项，使它们指向硬件自带的例程 #Highlight #[[2023-04-28]]
- BIOS在填写中断向量表，那该表是谁创建的呢？答案就是CPU原生支持的，不用谁负责创建 #Highlight #[[2023-04-28]]
- 软件中只要执行int 中断向量号，CPU便会把向量号当作下标，去中断向量表中定位中断处理程序并执行 #Highlight #[[2023-04-28]]
- DOS是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和BIOS的不能冲突 #Highlight #[[2023-04-28]]
- Linux内核是在进入保护模式后才建立中断例程的 #Highlight #[[2023-04-28]]
- 在保护模式下，中断向量表已经不存在了，取而代之的是中断描述符表（Interrupt Descriptor Table，IDT） #Highlight #[[2023-04-28]]
- 在Linux下执行的中断调用，访问的中断例程是在中断描述符表中，已不在中断向量表里了 #Highlight #[[2023-04-28]]
- 如果在实模式下执行int指令，会自动去访问中断向量表。如果在保护模式下执行int指令，则会自动访问中断描述符表 #Highlight #[[2023-04-28]]
- 保护模式下对任何内存的访问都要经过段描述符才行。比如程序代码所在的段描述符权限属性必须是只读，数据所在的段描述符的权限属性必然是可读写，程序中那些只读的节（比如代码区域）必然不能指向可读写的段描述符，同样，程序中的数据也不能用只读权限的段描述符去访问 #Highlight #[[2023-04-28]]
- 链接器将目标文件中属性相同的节合并成一个大的section集合，此集合便称为segment，也就是段，此段便是我们平时所说的可执行程序内存空间中的代码段和数据段 #Highlight #[[2023-04-28]]
- section称为节，是指在汇编源码中经由关键字section或segment修饰、逻辑划分的指令或数据区域，汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说“节”最初诞生于目标文件中。
  segment称为段，是链接器根据目标文件中属性相同的多个section合并后的section集合，这个集合称为segment，也就是段，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中。我们平时所说的可执行程序内存空间中的代码段和数据段就是指的segment。 #Highlight #[[2023-04-28]]
- 文件系统也有自己的魔数，魔数的神秘力量在此施展了。各分区都有超级块，一般位于本分区的第2个扇区，比如若各分区的扇区以0开始索引，其第1个扇区便是超级块的起始扇区。超级块里面记录了此分区的信息，其中就有文件系统的魔数，一种文件系统对应一个魔数，比对此值便知道文件系统类型了。 #Highlight #[[2023-04-28]]
- 我们常说的用于存放下一条指令地址的寄存器称为程序计数器PC（Program Counter）。这个名词在我看来是个概念级别的内容，它只是CPU中有关下一条指令存放地址的统称，也就是说PC是用来表示下一条指令的存放地址，具体的实现形式不限 #Highlight #[[2023-04-28]]
- 在x86体系结构的CPU中，也就是咱们大多数人使用的INTEL或AMD公司出品的桌面处理器，程序计数器PC并不是单一的某种寄存器，它是一种寄存器组合，指的段寄存器CS和指令指令寄存器IP。 #Highlight #[[2023-04-28]]
- CS和IP是CPU待执行的下一条指令的段基址和段内偏移地址，不能直接用mov指令去改变它们 #Highlight #[[2023-04-28]]
- mov指令一次只能改变一个寄存器，不能同时将cs和ip都改变。如果只改变了其中一个会引起错误 #Highlight #[[2023-04-28]]
- 有专门改变执行流的指令，如jmp、call、int、ret，这些指令可以同时修改cs和ip #Highlight #[[2023-04-28]]
- 拿ARM举例，它的程序计数器有个专门的寄存器，名字就叫PC，想要改变程序流程，直接对该寄存器赋值便可 #Highlight #[[2023-04-28]]
- 程序计数器PC负责处理器的执行方向，它只是获取下一条指令的方法形式，在不同体系结构的CPU中有不同的实现方法 #Highlight #[[2023-04-28]]
- 目前CPU中的指令，无论是哪种指令集，都由操作码和操作数两部分组成（有些指令即使指令格式中没有列出操作数，也会有隐含的操作数） #Highlight #[[2023-04-28]]
- 我们常用的CPU是Intel和AMD公司的产品，它们用的指令集便是基于CISC思想的x86。AMD的x86指令架构是Intel授权给他们的，为区别于此，Intel在官方手册上称自己的指令集为IA32 #Highlight #[[2023-04-28]]
- 目前市面上常见的指令集有五种，除x86是CISC指令体系外，ARM、MIPS、Power、C6000都是RISC指令体系的指令集 #Highlight #[[2023-04-28]]
- CPU与指令集是对应的，一种CPU只能识别一种指令集，所以很多CPU都以其支持的指令集来称呼。比如ARM、MIPS，它们本身是CPU名称，又是指令集名称。 #Highlight #[[2023-04-28]]
- 平时所说的编程语言，虽然其上层表现各异，归根结底是要在具体的CPU上运行的，所以必须由编译器按照该CPU的指令集，翻译成符合该CPU的指令 #Highlight #[[2023-04-28]]
- 本质上交叉编译就是用在A平台上运行的编译器，编译出符合B平台CPU指令集的程序，编译出的程序直接能在B平台上运行啦。这里的平台指的就是CPU指令体系结构 #Highlight #[[2023-04-28]]
- gcc编译时加-E参数就可以获取预处理后的文件内容 #Highlight #[[2023-05-01]]
- gcc编译时加-v参数会将编译、链接两个过程详细地打印出来 #Highlight #[[2023-05-01]]
- 编译阶段是将C代码翻译成汇编代码，由最上面的框框中的C语言编译器cc1来完成，它将C代码文件main.c翻译成汇编文件ccymR62K.s #Highlight #[[2023-05-01]]
- 汇编阶段是将汇编代码编译成目标文件，用第二个框框中的汇编语言编译器as完成，as将汇编文件ccymR62K.s编译成目标文件cc0yJGmy.o #Highlight #[[2023-05-01]]
- 链接阶段是将所有使用的目标文件链接成可执行文件，这是用左边最下面框框中的链接器collect2来完成的，它只是链接命令ld的封装，最终还是由ld来完成 #Highlight #[[2023-05-01]]
- 重定位文件意思是文件中的函数是没有地址的，用file命令查看它们时会显示relocatable，它们中的地址是在与用户程序的目标文件链接成一个可执行文件时由链接器统一分配的 #Highlight #[[2023-05-01]]
- ltrace命令用来跟踪程序运行时调用的库函数 #Highlight #[[2023-05-01]]
- 如果大家不想安装ltrace命令，可以用本机自带的strace命令代替，它是专门用来查看系统调用和信号的命令，不过它查看的并不是最终的系统调用，而是系统调用的封装函数。 #Highlight #[[2023-05-01]]
- 用户程序可以不和操作系统打交道，但如果需要操作系统的支持，必须要通过系统调用，它是用户进程和操作系统之间的“钩子”，用户进程顶多算是个半成品，只有通过钩子挂上了操作系统，加了上所需要的操作系统的那部分代码，用户程序才能做完一件事，这才算完整 #Highlight #[[2023-05-01]]
- ASCII码表中字符按可见分成两大类，一类是不可见字符，共33个，它们的ASCII码值是0～31和127，属于控制字符或通信专用字符。表中其余的字符是可见字符，它们的ASCII码值是32～126，属于数字、字母、各种符号。 #Highlight #[[2023-05-01]]
- MBR是主引导记录，Master或Main Boot Record，它存在于整个硬盘最开始的那个扇区，即0盘0道1扇区 #Highlight #[[2023-05-01]]
- 一般情况下扇区大小是512字节，但大伙儿不要把这个当真理，有的硬盘扇区并不是512字节 #Highlight #[[2023-05-01]]
- 在MBR引导扇区中的内容是：
  （1）446字节的引导程序及参数；
  （2）64字节的分区表；
  （3）2字节结束标记0x55和0xaa。 #Highlight #[[2023-05-01]]
- BIOS知道MBR在0盘0道1扇区，这是约定好的，因此它会将0盘0道1扇区中的MBR引导程序加载到物理地址0x7c00，然后跳过去执行，这样BIOS就把处理器使用权移交给MBR了 #Highlight #[[2023-05-01]]
- MBR引导扇区中除了引导程序外，还有64字节大小的分区表，里面是分区信息。分区表中每个分区表项占16字节，因此MBR分区表中可容纳4个分区，这4个分区就是“次引导程序”的候选人群，MBR引导程序开始遍历这4个分区，想找到合适的人选并把系统控制权交给他 #Highlight #[[2023-05-01]]
- 通常情况下这个“次引导程序”就是操作系统提供的加载器 #Highlight #[[2023-05-01]]
- 为了让MBR知道哪里有操作系统，我们在分区时，如果想在某个分区中安装操作系统，就用分区工具将该分区设置为活动分区 #Highlight #[[2023-05-01]]
- 设置活动分区的本质就是把分区表中该分区对应的分区表项中的活动标记为0x80 #Highlight #[[2023-05-01]]
- 活动分区标记位于分区表项中最开始的1字节（有关分区内容，后面介绍分区的章节中会细说），其值要么为0x80，要么为0，其他值都是非法的。0x80表示此分区上有引导程序，0表示没引导程序，该分区不可引导 #Highlight #[[2023-05-01]]
- 为了MBR方便找到活动分区上的内核加载器，内核加载器的入口地址也必须在固定的位置，这个位置就是各分区最开始的扇区，这也是约定好的。这个“各分区起始的扇区”中存放的是操作系统引导程序——内核加载器，因此该扇区称为操作系统引导扇区，其中的引导程序（内核加载器）称为操作系统引导记录OBR，即OS Boot Record，此扇区也称为OBR引导扇区。在OBR扇区的前3个字节存放了跳转指令，这同样是约定，因此MBR找到活动分区后，就大胆主动跳到活动分区OBR引导扇区的起始处，该起始处的跳转指令马上将处理器带入操作系统引导程序，从此MBR完成了交接工作，以后便是内核的天下了。 #Highlight #[[2023-05-01]]
- EBR与MBR结构相同，但位置和数量都不同，整个硬盘只有1个MBR，其位于整个硬盘最开始的扇区——0道0道1扇区。而EBR可有无数个，具体位置取决于扩展分区的分配情况，总之是位于各子扩展分区最开始的扇区 #Highlight #[[2023-05-01]]
- MBR和EBR是分区工具创建维护的，不属于操作系统管理的范围，因此操作系统不可以往里面写东西 #Highlight #[[2023-05-01]]
- DBR、OBR、MBR、EBR都包含引导程序，因此它们都称为引导扇区，只要该扇区中存在可执行的程序，该扇区就是可引导扇区 #Highlight #[[2023-05-01]]
- 若该扇区位于整个硬盘最开始的扇区，并且以0x55和0xaa结束，BIOS就认为该扇区中存在MBR，该扇区就是MBR引导扇区。若该扇区位于各分区最开始的扇区，并且以0x55和0xaa结束，MBR就认为该扇区中有操作系统引导程序OBR，该扇区就是OBR引导扇区 #Highlight #[[2023-05-01]]
- 各子扩展分区中只有一个逻辑分区 #Highlight #[[2023-05-01]]
- MBR和EBR位于分区之外的扇区 #Highlight #[[2023-05-01]]