alias:: Number of Good Paths

- #CruelCoding #2022-10-18 #Hard #[[Union Find]] #[[Path in a tree]] Rating-2444
- #Algorithm #Hard #[[数组]] #[[图]] #[[并查集]] #[[树]]
- #Leetcode #Leetcode-2421 [LC国际](https://leetcode.com/problems/number-of-good-paths/) [LC中国](https://leetcode.cn/problems/number-of-good-paths/)
- # 题目
	- 给你一棵 `n` 个节点的树（连通无向无环的图），节点编号从 `0` 到 `n - 1` 且恰好有 `n - 1` 条边。
	- 给你一个长度为 `n` 下标从 **0** 开始的整数数组 `vals` ，分别表示每个节点的值。同时给你一个二维整数数组 `edges` ，其中 `edges[i] = [ai, bi]` 表示节点 `ai` 和 `bi`之间有一条 **无向** 边。
	- 一条 **好路径** 需要满足以下条件：
	- 开始节点和结束节点的值 **相同** 。
	- 开始节点和结束节点中间的所有节点值都 **小于等于** 开始节点的值（也就是说开始节点的值应该是路径上所有节点的最大值）。
	- 请你返回不同好路径的数目。
	- 注意，一条路径和它反向的路径算作 **同一** 路径。比方说， `0 -> 1` 与 `1 -> 0` 视为同一条路径。单个节点也视为一条合法路径。
	-
	- **示例 1：**
		- ![](https://assets.leetcode.com/uploads/2022/08/04/f9caaac15b383af9115c5586779dec5.png)
		- **输出：**6
		- **解释：**总共有 5 条单个节点的好路径。
		- 还有 1 条好路径：1 -> 0 -> 2 -> 4 。
		- （反方向的路径 4 -> 2 -> 0 -> 1 视为跟 1 -> 0 -> 2 -> 4 一样的路径）
		- 注意 0 -> 2 -> 3 不是一条好路径，因为 vals[2] > vals[0] 。
	- **示例 2：**
		- ![](https://assets.leetcode.com/uploads/2022/08/04/149d3065ec165a71a1b9aec890776ff.png)
		- **输出：**7
		- **解释：**总共有 5 条单个节点的好路径。
		- 还有 2 条好路径：0 -> 1 和 2 -> 3 。
	- **示例 3：**
		- ![](https://assets.leetcode.com/uploads/2022/08/04/31705e22af3d9c0a557459bc7d1b62d.png)
		- **输出：**1
		- **解释：**这棵树只有一个节点，所以只有一条好路径。
		-
	- **提示：**
		- `n == vals.length`
		- `1 <= n <= 3 * 104`
		- `0 <= vals[i] <= 105`
		- `edges.length == n - 1`
		- `edges[i].length == 2`
		- `0 <= ai, bi < n`
		- `ai != bi`
		- `edges` 表示一棵合法的树。
- # 解
	- ## 并查集
		- ```python
		  class UnionFind:
		      def __init__(self, size):
		          self.values = list(range(size))
		      
		      def get_father(self, i):
		          while i != self.values[i]:
		              j = self.get_father(self.values[i])
		              self.values[i] = j
		              i = j
		          
		          return i
		      
		      def is_friend(self, i, j):
		          return self.get_father(i) == self.get_father(j)
		      
		      def union(self, i, j):
		          i = self.get_father(i)
		          j = self.get_father(j)
		          if i != j:
		              self.values[i] = j
		  
		  class Solution:
		      def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:
		          for e in edges:
		              if vals[e[0]] < vals[e[1]]:
		                  e[0], e[1] = e[1], e[0]
		              # make sure vals[e[0]] >= vals[e[1]]
		          
		          edges = [e + [vals[e[0]]] for e in edges]
		          edges.sort(key=lambda e: e[2])
		          edgesGroup = [(k, list(es)) for (k, es) in groupby(edges, key=lambda x: x[-1])]
		          
		          v2ids = defaultdict(list)
		          for i, v in enumerate(vals):
		              v2ids[v].append(i)
		          
		          # print(v2ids)
		          
		          uf = UnionFind(len(vals))
		  
		          # nodes = [(k, [t[0] for t in v]) for (k, v) in groupby(sorted(enumerate(vals), key=lambda x: x[1]), key=lambda x: x[1])]
		          
		          # print(nodes)
		          # print(edges)
		          # print(edgesGroup)
		          
		          count = 0
		          for k, edges in edgesGroup:
		              for edge in edges:
		                  uf.union(edge[0], edge[1])
		              
		              counts = defaultdict(int)
		              for node in v2ids[k]:
		                  counts[uf.get_father(node)] += 1
		                  
		              for x in counts.values():
		                  count += x * (x-1) // 2
		                      
		          
		          return len(vals) + count
		  ```