- #CruelFundamental #2022-11-21 [讨论](https://github.com/CYZH1307/CruelFundamental/tree/main/homework/202211/21) #内存
-
- 虚拟内存是物理内存的抽象
- （在保护模式下）对于每个进程而言，其可见的是虚拟内存，包括了内核内存和给自己分配的内存，每个进程都会「觉得」自己是唯一的进程、可使用所有内存（甚至超过物理内存大小）
-
- 逻辑地址转换为物理地址
	- 方案一：利用段
	- 方案二：利用页
		- ![](https://static001.geekbang.org/resource/image/9e/57/9eed9b0e3e7823c28d80c36e535e5d57.jpg?wh=2000x1266)
		- 第一步是确定**页目录基址**。每个 CPU 都有一个页目录基址寄存器，最高级页表的基地址就存在这个寄存器里。在 X86 上，这个寄存器是 CR3。每一次计算物理地址时，MMU 都会从 CR3 寄存器中取出页目录所在的物理地址。
		- 第二步是定位**页目录项（PDE）**。一个 32 位的虚拟地址可以拆成 10 位，10 位和 12 位三段，上一步找到的页目录表基址加上高 10 位的值乘以 4，就是页目录项的位置。这是因为，一个页目录项正好是 4 字节，所以 1024 个页目录项共占据 4096 字节，刚好组成一页，而 1024 个页目录项需要 10 位进行编码。这样，我们就可以通过最高 10 位找到该地址所对应的 PDE 了。
		- 第三步是定位**页表项（PTE）**。页目录项里记录着页表的位置，CPU 通过页目录项找到页表的位置以后，再用中间 10 位计算页表中的偏移，可以找到该虚拟地址所对应的页表项了。页表项也是 4 字节的，所以一页之内刚好也是 1024 项，用 10 位进行编码。所以计算公式与上一步相似，用页表基址加上中间 10 位乘以 4，可以得到页表项的地址。
		- 最后一步是**确定真实的物理地址**。上一步 CPU 已经找到页表项了，这里存储着物理地址，这才真正找到该虚拟地址所对应的物理页。虚拟地址的低 12 位，刚好可以对一页内的所有字节进行编码，所以我们用低 12 位来代表页内偏移。计算的公式是物理页的地址直接加上低 12 位。
-