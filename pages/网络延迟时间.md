alias:: Network Delay Time

- #CruelCoding #2022-12-13 #Medium #[[BFS+PQ]] #[[Dijkstra]] [讲解](https://youtu.be/Jlhgi5-npKI)
- #Algorithm #Medium #[[图]] #[[最短路]] #[[深度优先搜索]] #[[广度优先搜索]] #[[堆（优先队列）]]
- #Leetcode #Leetcode-743 [LC国际](https://leetcode.com/problems/network-delay-time/) [LC中国](https://leetcode.cn/problems/network-delay-time/)
- #lintcode #Lintcode-1057 [LintCode](https://www.lintcode.com/problem/1057/)
- # 题目
	- 有 `n` 个网络节点，标记为 `1` 到 `n`。
	- 给你一个列表 `times`，表示信号经过 **有向** 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点， `wi` 是一个信号从源节点传递到目标节点的时间。
	- 现在，从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 。
	-
	- **示例 1：**
		- ![](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)
		- **输入：**times =`[[2,1,1],[2,3,1],[3,4,1]]` , n = 4, k = 2
		- **输出：**2
	- **示例 2：**
		- **输入：**times = `[[1,2,1]]`, n = 2, k = 1
		- **输出：**1
	- **示例 3：**
		- **输入：**times = `[[1,2,1]]`, n = 2, k = 2
		- **输出：**-1
		-
	- **提示：**
		- `1 <= k <= n <= 100`
		- `1 <= times.length <= 6000`
		- `times[i].length == 3`
		- `1 <= ui, vi <= n`
		- `ui != vi`
		- `0 <= wi <= 100`
		- 所有 `(ui, vi)` 对都 **互不相同**（即，不含重复边）
- # 解
	- ## 标准做法（无优化）
		- [正确性证明](https://leetcode-cn.com/submissions/detail/264875179/)
		- ```java
		  class Solution {
		  
		      public int networkDelayTime(int[][] times, int n, int k) {
		          List<int[]>[] edges = new List[n+1];
		          int[] distanceMap = new int[n+1];
		          boolean[] exclude = new boolean[n+1];
		          for (int i = 1; i <= n; i++) {
		              edges[i] = new ArrayList();
		              distanceMap[i] = Integer.MAX_VALUE;
		          }
		          for (int[] time: times) {
		              edges[time[0]].add(time);
		          }
		          
		          distanceMap[k] = 0;
		          int minNode = k;
		          do {
		              int distance = distanceMap[minNode];
		  
		              for (int[] edge: edges[minNode]) {
		                  int currentDistance = distance + edge[2];
		  
		                  if (currentDistance < distanceMap[edge[1]]) {
		                       distanceMap[edge[1]] = currentDistance;
		                  }
		              }
		  
		              exclude[minNode] = true;
		          } while ((minNode = getMinAndNotExclude(distanceMap, exclude)) != -1);
		  
		  
		          int maxValue = 0;
		          for (int i = 1; i <= n; i++) {
		              maxValue = Math.max(maxValue, distanceMap[i]);
		          }
		  
		          return maxValue == Integer.MAX_VALUE ? -1 : maxValue;
		      }
		  
		      int getMinAndNotExclude(int[] distanceMap, boolean[] exclude) {
		          int minNode = -1;
		          int minDist = Integer.MAX_VALUE;
		  
		          for (int i = 1; i < distanceMap.length; i++) {
		              if (!exclude[i] && distanceMap[i] < minDist) {
		                  minNode = i;
		                  minDist = distanceMap[i];
		              }
		          }
		  
		          return minNode;
		      }
		  }
		  ```
	- ## 堆优化解法
		- #TODO [答案](https://github.com/algorithmzuo/algorithmbasic2020/blob/master/src/class16/Code06_NetworkDelayTime.java#L13)
	- ## 加强堆优化解法
		- #TODO [答案](https://github.com/algorithmzuo/algorithmbasic2020/blob/master/src/class16/Code06_NetworkDelayTime.java#L44)