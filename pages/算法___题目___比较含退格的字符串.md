title:: 算法/题目/比较含退格的字符串
- alias:: Backspace String Compare
- #算法 #Easy #[[模拟]] #[[双指针]] #[[字符串]] #[[栈]]
- #Leetcode #Leetcode-844 [LC国际](https://leetcode.com/problems/backspace-string-compare/) [LC中国](https://leetcode-cn.com/problems/backspace-string-compare/)
- #lintcode #Lintcode-1425 [LintCode](https://www.lintcode.com/problem/1425/)
- # 题目
  collapsed:: true
	- 给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。
	- **注意：**如果对空文本输入退格字符，文本继续为空。
	-
	- **示例 1：**
		- **输入：**s = "ab#c", t = "ad#c"
		- **输出：**true
		- **解释：**s 和 t 都会变成 "ac"。
	- **示例 2：**
		- **输入：**s = "ab##", t = "c#d#"
		- **输出：**true
		- **解释：**s 和 t 都会变成 ""。
	- **示例 3：**
		- **输入：**s = "a#c", t = "b"
		- **输出：**false
		- **解释：**s 会变成 "c"，但 t 仍然是 "b"。
		-
		-
		-
	- **提示：**
		- `1 <= s.length, t.length <= 200`
		- `s` 和 `t` 只含有小写字母以及字符 `'#'`
		-
	- **进阶：**
		- 你可以用 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？
- # 解：构造出字符串
	- ```go
	  func backspaceCompare(s string, t string) bool {
	      return simplify(s) == simplify(t)
	  }
	  
	  func simplify(s string) string {
	      stack := []byte{}
	      
	      for i := range s {
	          if s[i] == '#' {
	              if len(stack) != 0 {
	                  stack = stack[:len(stack)-1]
	              }
	          } else {
	              stack = append(stack, s[i])
	          }
	      }
	      
	      return string(stack)
	  }
	  ```
- # 解：双指针
	- 空间复杂度 O(1)
	- https://leetcode.com/problems/backspace-string-compare/solution/ Approach 2
	- ```go
	  func backspaceCompare(s string, t string) bool {
	      i, j := len(s) - 1, len(t) - 1
	      
	      for {
	          skip := 0
	          for i >= 0 && (skip != 0 || s[i] == '#') {
	              if s[i] == '#' {
	                  skip++
	              } else {
	                  skip--
	              }
	  
	              i--
	          }
	          
	          skip = 0
	          for j >= 0 && (skip != 0 || t[j] == '#') {
	              if t[j] == '#' {
	                  skip++
	              } else {
	                  skip--
	              }
	  
	              j--
	          }
	                  
	          if i < 0 || j < 0 {
	              return i < 0 && j < 0
	          }
	          
	          if s[i] == t[j] {
	              i--
	              j--
	          } else {
	              return false
	          }
	      }
	  }
	  
	  
	  ```