alias:: Segment Tree

- 线段树是算法竞赛中常用的用来维护 **区间信息** 的数据结构。
- 线段树可以在  O(logN) 的时间复杂度内实现 **单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）**等操作。
	- 对比：[[树状数组]] 无法实现区间修改
-
- **建树**
	- 线段树将每个长度不为 1 的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。
	- ![](https://oi-wiki.org/ds/images/segt1.svg)
	- $d_i$ 的左儿子节点就是 $d_{2\times i}$，$d_i$ 的右儿子节点就是 $d_{2\times i+1}$
	- 如果 $d_i$ 表示的是区间 $[s,t]$（即 $d_i=a_s+a_{s+1}+ \cdots +a_t$) 的话，那么 $d_i$ 的左儿子节点表示的是区间 $[ s, \frac{s+t}{2} ]$，$d_i$ 的右儿子表示的是区间 $[ \frac{s+t}{2} +1,t ]$
	- 在实现时，我们考虑递归建树。
		- ```c++
		  void build(int s, int t, int p) {
		    // 对 [s,t] 区间建立线段树,当前根的编号为 p
		    if (s == t) {
		      d[p] = a[s];
		      return;
		    }
		    int m = s + ((t - s) >> 1);
		    // 移位运算符的优先级小于加减法，所以加上括号
		    // 如果写成 (s + t) >> 1 可能会超出 int 范围
		    build(s, m, p * 2), build(m + 1, t, p * 2 + 1);
		    // 递归对左右区间建树
		    d[p] = d[p * 2] + d[(p * 2) + 1];
		  }
		  ```
- **区间修改**
	- 如果要求修改区间 $[l,r]$，把所有包含在区间 $[l,r]$ 中的节点都遍历一次、修改一次，时间复杂度无法承受。我们这里要引入一个叫做 **「懒惰标记」** 的东西。
	- 懒惰标记，简单来说，就是通过延迟对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。
	-