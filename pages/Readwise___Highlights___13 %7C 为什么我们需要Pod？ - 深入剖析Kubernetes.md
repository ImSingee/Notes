title:: Readwise/Highlights/13 | 为什么我们需要Pod？ - 深入剖析Kubernetes
author:: [[张磊]]
full-title:: 13 | 为什么我们需要Pod？ - 深入剖析Kubernetes
category:: #articles
url:: https://time.geekbang.org/column/article/40092
- Pod，是 Kubernetes 项目中最小的 API 对象。如果换一个更专业的说法，我们可以这样描述：Pod，是 Kubernetes 项目的原子调度单位。 #Highlight #[[2022-08-12]]
- 他们部署的应用，往往都存在着类似于“进程和进程组”的关系。更具体地说，就是这些应用之间有着密切的协作关系，使得它们必须部署在同一台机器上。 #Highlight #[[2022-08-12]]
- 资源囤积带来了不可避免的调度效率损失和死锁的可能性；而乐观调度的复杂程度，则不是常规技术团队所能驾驭的。 #Highlight #[[2022-08-12]]
- Pod 是 Kubernetes 里的原子调度单位。这就意味着，Kubernetes 项目的调度器，是统一按照 Pod 而非容器的资源需求进行计算的。 #Highlight #[[2022-08-12]]
- 关于 Pod 最重要的一个事实是：它只是一个逻辑概念。 #Highlight #[[2022-08-12]]
- Kubernetes 真正处理的，还是宿主机操作系统上 Linux 容器的 Namespace 和 Cgroups，而并不存在一个所谓的 Pod 的边界或者隔离环境。 #Highlight #[[2022-08-12]]
- Pod 里的所有容器，共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume。 #Highlight #[[2022-08-12]]
- Pod，其实是一组共享了某些资源的容器。 #Highlight #[[2022-08-12]]
- 在 Kubernetes 项目里，Pod 的实现需要使用一个中间容器，这个容器叫作 Infra 容器。在这个 Pod 中，Infra 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起。 #Highlight #[[2022-08-12]]
- 在 Kubernetes 项目里，Infra 容器一定要占用极少的资源，所以它使用的是一个非常特殊的镜像，叫作：k8s.gcr.io/pause。这个镜像是一个用汇编语言编写的、永远处于“暂停”状态的容器，解压后的大小也只有 100~200 KB 左右。 #Highlight #[[2022-08-12]]
- 一个 Pod 只有一个 IP 地址，也就是这个 Pod 的 Network Namespace 对应的 IP 地址； #Highlight #[[2022-08-12]]
- Pod 的生命周期只跟 Infra 容器一致，而与容器 A 和 B 无关。 #Highlight #[[2022-08-12]]
- 对于同一个 Pod 里面的所有用户容器来说，它们的进出流量，也可以认为都是通过 Infra 容器完成的。这一点很重要，因为将来如果你要为 Kubernetes 开发一个网络插件时，应该重点考虑的是如何配置这个 Pod 的 Network Namespace，而不是每一个用户容器如何使用你的网络配置，这是没有意义的。
  这就意味着，如果你的网络插件需要在容器里安装某些包或者配置才能完成的话，是不可取的：Infra 容器镜像的 rootfs 里几乎什么都没有，没有你随意发挥的空间。当然，这同时也意味着你的网络插件完全不必关心用户容器的启动与否，而只需要关注如何配置 Pod，也就是 Infra 容器的 Network Namespace 即可。 #Highlight #[[2022-08-12]]
- 当用户想在一个容器里跑多个功能并不相关的应用时，应该优先考虑它们是不是更应该被描述成一个 Pod 里的多个容器。 #Highlight #[[2022-08-12]]
- 在 Pod 中，所有 Init Container 定义的容器，都会比 spec.containers 定义的用户容器先启动。并且，Init Container 容器会按顺序逐一启动，而直到它们都启动并且退出了，用户容器才会启动。 #Highlight #[[2022-08-12]]
- 这个所谓的“组合”操作，正是容器设计模式里最常用的一种模式，它的名字叫：sidecar。
  顾名思义，sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进程（主容器）之外的工作。 #Highlight #[[2022-08-12]]
- Istio 项目使用 sidecar 容器完成微服务治理的原理 #Highlight #[[2022-08-12]]
- 无论是从具体的实现原理，还是从使用方法、特性、功能等方面，容器与虚拟机几乎没有任何相似的地方；也不存在一种普遍的方法，能够把虚拟机里的应用无缝迁移到容器中。因为，容器的性能优势，必然伴随着相应缺陷，即：它不能像虚拟机那样，完全模拟本地物理机环境中的部署方法。 #Highlight #[[2022-08-12]]
- Namespace 做隔离，Cgroups 做限制，rootfs 做文件系统 #Highlight #[[2023-06-07]]
- Kubernetes 就是操作系统 #Highlight #[[2023-06-07]]
- Mesos 中就有一个资源囤积（resource hoarding）的机制，会在所有设置了 Affinity 约束的任务都达到时，才开始对它们统一进行调度。而在 Google Omega 论文中，则提出了使用乐观调度处理冲突的方法，即：先不管这些冲突，而是通过精心设计的回滚机制在出现了冲突之后解决问题。 #Highlight #[[2023-06-07]]
- 资源囤积带来了不可避免的调度效率损失和死锁的可能性；而乐观调度的复杂程度，则不是常规技术团队所能驾驭的 #Highlight #[[2023-06-07]]
- 到了 Kubernetes 项目里，这样的问题就迎刃而解了：Pod 是 Kubernetes 里的原子调度单位。这就意味着，Kubernetes 项目的调度器，是统一按照 Pod 而非容器的资源需求进行计算的 #Highlight #[[2023-06-07]]
- 有“超亲密关系”容器的典型特征包括但不限于：互相之间会发生直接的文件交换、使用 localhost 或者 Socket 文件进行本地通信、会发生非常频繁的远程调用、需要共享某些 Linux Namespace（比如，一个容器要加入另一个容器的 Network Namespace）等等。 #Highlight #[[2023-06-07]]
- 关于 Pod 最重要的一个事实是：它只是一个逻辑概念。
  也就是说，Kubernetes 真正处理的，还是宿主机操作系统上 Linux 容器的 Namespace 和 Cgroups，而并不存在一个所谓的 Pod 的边界或者隔离环境。 #Highlight #[[2023-06-07]]
- Pod 里的所有容器，共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume #Highlight #[[2023-06-07]]
- 在 Kubernetes 项目里，Pod 的实现需要使用一个中间容器，这个容器叫作 Infra 容器。在这个 Pod 中，Infra 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起 #Highlight #[[2023-06-07]]
- 对于 Pod 里的容器 A 和容器 B 来说：
  它们可以直接使用 localhost 进行通信；
  它们看到的网络设备跟 Infra 容器看到的完全一样；
  一个 Pod 只有一个 IP 地址，也就是这个 Pod 的 Network Namespace 对应的 IP 地址；
  当然，其他的所有网络资源，都是一个 Pod 一份，并且被该 Pod 中的所有容器共享；
  Pod 的生命周期只跟 Infra 容器一致，而与容器 A 和 B 无关。 #Highlight #[[2023-06-07]]
- 对于同一个 Pod 里面的所有用户容器来说，它们的进出流量，也可以认为都是通过 Infra 容器完成的。这一点很重要，因为将来如果你要为 Kubernetes 开发一个网络插件时，应该重点考虑的是如何配置这个 Pod 的 Network Namespace，而不是每一个用户容器如何使用你的网络配置，这是没有意义的 #Highlight #[[2023-06-07]]
- 如果你的网络插件需要在容器里安装某些包或者配置才能完成的话，是不可取的：Infra 容器镜像的 rootfs 里几乎什么都没有，没有你随意发挥的空间。当然，这同时也意味着你的网络插件完全不必关心用户容器的启动与否，而只需要关注如何配置 Pod，也就是 Infra 容器的 Network Namespace 即可 #Highlight #[[2023-06-07]]
- Pod 这种“超亲密关系”容器的设计思想，实际上就是希望，当用户想在一个容器里跑多个功能并不相关的应用时，应该优先考虑它们是不是更应该被描述成一个 Pod 里的多个容器。 #Highlight #[[2023-06-07]]
- 所谓的“组合”操作，正是容器设计模式里最常用的一种模式，它的名字叫：sidecar。
  顾名思义，sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进程（主容器）之外的工作。 #Highlight #[[2023-06-07]]
- Pod 的另一个重要特性是，它的所有容器都共享同一个 Network Namespace。这就使得很多与 Pod 网络相关的配置和管理，也都可以交给 sidecar 完成，而完全无须干涉用户容器。这里最典型的例子莫过于 Istio 这个微服务治理项目了 #Highlight #[[2023-06-07]]
- Pod，实际上是在扮演传统基础设施里“虚拟机”的角色；而容器，则是这个虚拟机里运行的用户程序。 #Highlight #[[2023-06-07]]
- 可以把整个虚拟机想象成为一个 Pod，把这些进程分别做成容器镜像，把有顺序关系的容器，定义为 Init Container。这才是更加合理的、松耦合的容器编排诀窍，也是从传统应用架构，到“微服务架构”最自然的过渡方式。 #Highlight #[[2023-06-07]]
- Pod 这个概念，提供的是一种编排思想，而不是具体的技术方案。所以，如果愿意的话，你完全可以使用虚拟机来作为 Pod 的实现，然后把用户容器都运行在这个虚拟机里。比如，Mirantis 公司的virtlet 项目就在干这个事情。甚至，你可以去实现一个带有 Init 进程的容器项目，来模拟传统应用的运行方式 #Highlight #[[2023-06-07]]
- 如果强行把整个应用塞到一个容器里，甚至不惜使用 Docker In Docker 这种在生产环境中后患无穷的解决方案，恐怕最后往往会得不偿失。 #Highlight #[[2023-06-07]]