title:: Readwise/Highlights/03 | 内存布局：应用程序是如何安排数据的？ - 编程高手必学的内存知识
author:: [[海纳]]
full-title:: 03 | 内存布局：应用程序是如何安排数据的？ - 编程高手必学的内存知识
category:: #articles
url:: https://time.geekbang.org/column/article/431904
- 从 0 地址开始的内存区域并不是直接就是代码段区域，而是一段不可访问的保留区。这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。 #Highlight #[[2022-10-18]]
- 在实践中，我们可以通过cat /proc/pid/maps来查看某个进程的实际虚拟内存布局。 #Highlight #[[2022-10-18]]
- Section 主要是指在磁盘中的程序段，而 Segment 则用来指代内存中的程序段，Segment 是将具有相同权限属性的 Section 集合在一起，系统为它们分配的一块内存空间。 #Highlight #[[2023-04-18]]
- 对于未初始化的全局变量和静态变量，因为编译器知道它们的初始值都是 0，因此便不需要再在程序的二进制映像中存放这么多 0 了，只需要记录他们的大小即可，这便是 BSS 段。BSS 段这个缩写名字是 Block Started by Symbol，但很多人可能更喜欢把它记作 Better Save Space 的缩写。 #Highlight #[[2022-10-18]]
- 对于有初值的变量，它的初始值会存放在程序的二进制文件中，而且，这些数据部分也会被装载到内存中，即程序的数据段。数据段存放的是程序中已经初始化且不为 0 的全局变量和静态变量。 #Highlight #[[2022-10-18]]
- 如果打开进程地址随机化的模式，其中的堆空间、栈空间和共享库映射的地址，在每次程序运行下都会不一样。这是因为内核在加载的过程中，会对这些区域的起始地址增加一些随机的偏移值，这能增加缓冲区溢出的难度。 #Highlight #[[2022-10-18]]
- 私有文件映射常用于加载动态库 #Highlight #[[2022-10-21]]
- 私有匿名映射常用于分配内存，也就是我们上文讲的申请堆内存 #Highlight #[[2022-10-21]]
- mmap 的功能非常强大，根据参数的不同，它可以用于创建共享内存，也可以创建文件映射区域用于提升 IO 效率，还可以用来申请堆内存。决定它的功能的，主要是 prot, flags 和 fd 这三个参数 #Highlight #[[2022-10-21]]
- 在 C 语言的运行时库里，malloc 向程序提供分配一小块内存的功能，当运行时库的内存分配完之后，它会使用 sbrk 方法向操作系统再申请一块大的内存。我们可以将 C 语言的运行时库类比为零售商，它从操作系统那里批发一块比较大的内存，然后再通过零售的方式一点点地提供给程序员使用。 #Highlight #[[2023-04-18]]
- sbrk 通过给内核的 brk 变量增加 incr，来改变堆的大小，incr 可以为负数 #Highlight #[[2023-04-18]]
- 不管是 32 位系统还是 64 位系统，内核都会维护一个变量 brk，指向堆的顶部，所以，brk 的位置实际上就决定了堆的大小。Linux 系统为我们提供了两个重要的系统调用来修改堆的大小，分别是 sbrk 和 mmap #Highlight #[[2023-04-18]]
- 对于 64 位的程序，你在查看 /proc/pid/maps 的过程中，会发现代码段跟数据段的中间还有一段不可以读写的保护段，它的作用也是防止程序在读写数据段的时候越界访问到代码段，这个保护段可以让越界访问行为直接崩溃，防止它继续往下运行。 #Highlight #[[2023-04-18]]
- 在用户空间和内核空间之间有一个巨大的内存空洞。这块空间之所以用更深颜色来区分，是因为这块空间的不可访问是由 CPU 来保证的（这里的地址都不满足 Intel 64 的 Canonical form）。 #Highlight #[[2023-04-18]]
- 目前的 64 系统下的寻址空间是 2^48，即 256TB。而且根据 canonical address 的划分，地址空间天然地被分割成两个区间，分别是 0x0 - 0x00007fffffffffff 和 0xffff800000000000 - 0xffffffffffffffff。这样就直接将低 128T 的空间划分为用户空间，高 128T 划分为内核空间 #Highlight #[[2023-04-18]]
- 64 位系统理论的寻址范围是 2^64，也就是 16EB。但是，从目前来看，我们的系统和应用往往用不到这么庞大的地址空间。因此，在目前的 Intel 64 架构里定义了 canonical address 的概念，即在 64 位的模式下，如果地址位 63 到地址的最高有效位被设置为全 1 或全零，那么该地址被认为是 canonical form。目前，Intel 64 处理器往往支持 48 位的虚拟地址，这意味着 canonical address 必须将第 63 位到第 48 位设置为零或一（这取决于第 47 位是零还是一）。 #Highlight #[[2023-04-18]]
- 堆的指针叫做“Program break”，栈的指针叫做“Stack pointer” #Highlight #[[2023-04-18]]
- 代码段从 0x08048000 的位置开始排布（需要注意的是，以上地址需要 gcc 编译的时候不开启 pie 的选项） #Highlight #[[2023-04-18]]
- 在 32 位机器上，每个进程都具有 4GB 的寻址能力。Linux 系统会默认将高地址的 1GB 空间分配给内核，剩余的低 3GB 是用户可以使用的用户空间。 #Highlight #[[2023-04-18]]
- 往往多个 Section 会对应一个 Segment，例如.text、.rodata 等一些只读的 Section，会被映射到内存的一个只读 / 执行的 Segment 里；而.data、.bss 等一些可读写的 Section，则会被映射到内存的一个具有读写权限的 Segment 里。并且对于磁盘二进制中一些辅助信息的 Section，例如.symtab、.strtab 等，不需要在内存中进行映射。 #Highlight #[[2023-04-18]]
- 对于磁盘的程序，每一个单元结构称为 Section。我们可以通过 readelf -S 的选项，来查看二进制文件中所有的 Section 信息。对于右边的内存镜像，每一个单元结构称为 Segment。我们可以通过 readelf -l 的选项，来查看二进制文件加载到内存之后的 Segment 布局信息。 #Highlight #[[2023-04-18]]
- 如果一个进程依赖共享库，那对应的，该共享库的代码段、数据段、BSS 段也需要被加载到这个进程的地址空间中 #Highlight #[[2023-04-18]]
- 与代码段以及数据段不同的是，堆和栈并不是从磁盘中加载，它们都是由程序在运行的过程中申请，在程序运行结束后释放。 #Highlight #[[2023-04-18]]
- 对于有初值的变量，它的初始值会存放在程序的二进制文件中，而且，这些数据部分也会被装载到内存中，即程序的数据段。数据段存放的是程序中已经初始化且不为 0 的全局变量和静态变量。
  对于未初始化的全局变量和静态变量，因为编译器知道它们的初始值都是 0，因此便不需要再在程序的二进制映像中存放这么多 0 了，只需要记录他们的大小即可，这便是 BSS 段。BSS 段这个缩写名字是 Block Started by Symbol，但很多人可能更喜欢把它记作 Better Save Space 的缩写。 #Highlight #[[2023-04-18]]
- CPU 运行一个程序，实质就是在顺序执行该程序的机器码。一个程序的机器码会被组织到同一个地方，这个地方就是代码段 #Highlight #[[2023-04-18]]
- 通常，我们使用私有匿名映射来进行堆内存的分配 #Highlight #[[2023-04-18]]
- 一般来说，addr 参数只是建议操作系统尽量以 addr 为起始地址进行内存映射，但如果操作系统判断 addr 作为起始地址不能满足长度或者权限要求时，就会另外再找其他适合的区域进行映射。如果 flags 的值取是 MAP_FIXED 的话，就不再把 addr 看成是建议了，而是将其视为强制要求。如果不能成功映射，就会返回空指针。 #Highlight #[[2023-04-18]]