title:: Readwise/Highlights/大咖助阵｜曹春晖：聊聊 Go 语言的 GC 实现 - Tony Bai · Go语言第一课 (65)
author:: [[Tony Bai]]
full-title:: 大咖助阵｜曹春晖：聊聊 Go 语言的 GC 实现 - Tony Bai · Go语言第一课
category:: #articles
url:: https://time.geekbang.org/column/article/484271

- renas 是 Go 向操作系统申请内存时的最小单位，每个 arena 为 64MB 大小，在内存中可以部分连续，但整体是个稀疏结构。
  单个 arena 会被切分成以 8KB 为单位的 page，由 page allocator 管理，一个或多个 page 可以组成一个 mspan，每个 mspan 可以按照 sizeclass 再划分成多个 element。同样大小的 mspan 又分为 scan 和 noscan 两种，分别对应内部有指针的 object 和内部没有指针的 object。 #Highlight #[[2022-08-05]]
- 页分配器在 Go 语言中迭代了多个版本，从简单的 freelist 结构，到 treap 结构，再到现在最新版本的 radix 结构，它的查找时间复杂度也从 O(N) -> O(log(n)) -> O(1)。
  在当前版本中，我们只需要知道常数时间复杂度就可以确定空闲页组成的 radix tree 是否能够满足内存分配需求。若不满足，则要对 arena 继续进行切分，或向操作系统申请更多的 arena。 #Highlight #[[2022-08-05]]
- tcmalloc 通过维护一套多级缓存结构，降低了应用内存分配过程中对全局锁的使用频率，使小对象的内存分配做到了尽量无锁。 #Highlight #[[2022-08-05]]
- collector 要扫描的就是 allocator 管理的这些数据结构，应用不再使用的部分便应该被回收，通过 madvise 这个系统调用返还给操作系统 #Highlight #[[2022-08-05]]
- 应用需要在堆上申请内存时，会由编译器帮程序员自动调用 runtime.newobject，这时 allocator 会使用 mmap 这个系统调用从操作系统中申请内存，若 allocator 发现之前申请的内存还有富余，会从本地预先分配的数据结构中划分出一块内存，并把它以指针的形式返回给应用。在内存分配的过程中，allocator 要负责维护内存管理对应的数据结构。 #Highlight #[[2022-08-05]]
- 在传统的不带 GC 的编程语言中，我们需要关注对象的分配位置，要自己去选择对象是分配在堆还是栈上，但在 Go 这门有 GC 的语言中，集成了逃逸分析功能来帮助我们自动判断对象应该在堆上还是栈上，我们可以使用 go build -gcflags="-m" 来观察逃逸分析的结果 #Highlight #[[2022-08-05]]
- 在 Go 语言中，还有很多对象被分配在栈上。栈上的对象操作极其频繁，给栈上对象增加写屏障成本很高，所以 Go 是不给栈上对象开启屏障的 #Highlight #[[2022-08-05]]
- 在应用进入 GC 标记阶段前的 stw 阶段，会将全局变量 runtime.writeBarrier.enabled 修改为 true，这时所有的堆上指针修改操作在修改之前便会额外调用 runtime.gcWriteBarrier #Highlight #[[2022-08-05]]
- write barrier
  这里 barrier 的本质是 : snippet of code insert before pointer modify。不过，在并发编程领域也有 memory barrier，但这个含义与 GC 领域的 barrier 是完全不同的，在阅读相关材料时，你一定要注意不要混淆这两个概念。 #Highlight #[[2022-08-05]]
- 实现强 / 弱三色不变性均需要引入屏障技术。在 Go 语言中，使用写屏障，也就是 write barrier 来解决上述问题 #Highlight #[[2022-08-05]]
- 无论应用在与 GC 并发执行期间如何修改堆上对象的关系，只要修改之后，堆上对象能满足任意一种不变性，就不会发生对象的丢失问题。 #Highlight #[[2022-08-05]]
- 弱三色不变性（weak tricolor invariant），黑色对象可以指向白色对象，但指向的白色对象，必须有能从灰色对象可达的路径 #Highlight #[[2022-08-05]]
- 强三色不变性（strong tricolor invariant），禁止黑色对象指向白色对象 #Highlight #[[2022-08-05]]
- 三色不变性可以分为强三色不变性和弱三色不变性两种， #Highlight #[[2022-08-05]]
- 为了解决漏标，错标的问题，我们先需要定义“三色不变性”，如果我们的堆上对象的引用关系不管怎么修改，都能满足三色不变性，那么也不会发生对象丢失问题。 #Highlight #[[2022-08-05]]
- 在 GC 标记 worker 工作期间，应用还会不断地修改堆上对象的引用关系，这就可能导致对象丢失问题。 #Highlight #[[2022-08-05]]
- 协助标记会对应用的响应延迟产生影响，我们可以尝试降低应用的对象分配数量进行优化 #Highlight #[[2022-08-05]]
- 当应用分配内存过快时，后台的 mark worker 无法及时完成标记工作，这时应用本身需要进行堆内存分配时，会判断是否需要适当协助 GC 的标记过程，防止应用因为分配过快发生 OOM。 #Highlight #[[2022-08-05]]
- 在标记过程中，gc mark worker 会一边从工作队列（gcw）中弹出对象，一边把它的子对象 push 到工作队列（gcw）中，如果工作队列满了，则要将一部分元素向全局队列转移 #Highlight #[[2022-08-05]]
- 标记过程会将白色对象标记，并推进队列中变成灰色对象。 #Highlight #[[2022-08-05]]
- 标记过程是一个广度优先的遍历过程。它是扫描节点，将节点的子节点推到任务队列中，然后递归扫描子节点的子节点，直到所有工作队列都被排空为止 #Highlight #[[2022-08-05]]
- 在 Go 语言中，从根开始扫描的含义是从 .bss 段，.data 段以及 goroutine 的栈开始扫描，最终遍历整个堆上的对象树 #Highlight #[[2022-08-05]]
- Go 语言使用三色抽象作为其并发标记的实现。所以这里我们首先要理解三种颜色的抽象：
  黑表示已经扫描完毕，子节点扫描完毕（gcmarkbits = 1，且在队列外）；
  灰表示已经扫描完毕，子节点未扫描完毕（gcmarkbits = 1, 在队列内）；
  白表示未扫描，collector 不知道任何相关信息。
  使用三色抽象，主要是为了能让垃圾回收流程与应用流程并发执行，这样将对象扫描过程拆分为多个阶段，不需要一次性完成整个扫描流程。 #Highlight #[[2022-08-05]]
- 官方声称 Go 的 stw 已经是亚毫秒级了，但我们在高压力的系统中仍然能够看到毫秒级的 stw #Highlight #[[2022-08-05]]
- 在并发标记开始前和并发标记终止时，有两个短暂的 stw，该 stw 可以使用 pprof 的 pauseNs 来观测，也可以直接采集到监控系统中 #Highlight #[[2022-08-05]]
- 语义垃圾（semantic garbage），有些场景也被称为内存泄露，指的是从语法上可达（可以通过局部、全局变量被引用）的对象，但从语义上来讲他们是垃圾，垃圾回收器对此无能为力。 #Highlight #[[2022-08-05]]
- 并不是说 tcmalloc 完全没有内存碎片，不信你可以在代码里搜搜 max waste #Highlight #[[2022-08-05]]
- 并发标记与清扫重点在并发，是指垃圾回收的标记和清扫过程能够与应用代码并发执行。但并发标记清扫算法的一大缺陷是无法解决内存碎片问题，而 tcmalloc 恰好一定程度上缓解了内存碎片问题，两者配合使用相得益彰 #Highlight #[[2022-08-05]]
- Go 语言使用了并发标记与清扫算法作为它的 GC 实现。 #Highlight #[[2022-08-05]]