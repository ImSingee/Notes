title:: Readwise/Highlights/26.3. Continuous Archiving and Point-in-Time ...
author:: [[PostgreSQL Documentation]]
full-title:: 26.3. Continuous Archiving and Point-in-Time Recovery (PITR) \# 26.3.连续存档和时间点恢复 (PITR) \#
category:: #articles
url:: https://www.postgresql.org/docs/current/continuous-archiving.html
- At all times, PostgreSQL maintains a *write ahead log* (WAL) in the `pg_wal/` subdirectory of the cluster's data directory. The log records every change made to the database's data files. This log exists primarily for crash-safety purposes: if the system crashes, the database can be restored to consistency by “replaying” the log entries made since the last checkpoint. However, the existence of the log makes it possible to use a third strategy for backing up databases: we can combine a file-system-level backup with backup of the WAL files. If recovery is needed, we restore the file system backup and then replay from the backed-up WAL files to bring the system to a current state. This approach is more complex to administer than either of the previous approaches, but it has some significant benefits: ([View Highlight](https://read.readwise.io/read/01hbnrxpnvvxhxenxqnbsp82g8)) #Highlight #[[2023-10-01]]
- It is not necessary to replay the WAL entries all the way to the end. We could stop the replay at any point and have a consistent snapshot of the database as it was at that time. Thus, this technique supports *point-in-time recovery*: it is possible to restore the database to its state at any time since your base backup was taken. ([View Highlight](https://read.readwise.io/read/01hbns2adgpy6ks4w9hmyenarx)) #Highlight #[[2023-10-01]]
- pg_dump and pg_dumpall do not produce file-system-level backups and cannot be used as part of a continuous-archiving solution. Such dumps are *logical* and do not contain enough information to be used by WAL replay. ([View Highlight](https://read.readwise.io/read/01hbns387a2z39skpb5qmr3az2)) #Highlight #[[2023-10-01]]
- The archive command or function is only invoked on completed WAL segments. Hence, if your server generates only little WAL traffic (or has slack periods where it does so), there could be a long delay between the completion of a transaction and its safe recording in archive storage. To put a limit on how old unarchived data can be, you can set [archive_timeout](https://www.postgresql.org/docs/current/continuous-archiving.html/runtime-config-wal.html#GUC-ARCHIVE-TIMEOUT) to force the server to switch to a new WAL segment file at least that often. Note that archived files that are archived early due to a forced switch are still the same length as completely full files. It is therefore unwise to set a very short `archive_timeout` — it will bloat your archive storage. `archive_timeout` settings of a minute or so are usually reasonable. ([View Highlight](https://read.readwise.io/read/01hbns5a61qnmp067yp9pd60ef)) #Highlight #[[2023-10-01]]
- Also, you can force a segment switch manually with `pg_switch_wal` if you want to ensure that a just-finished transaction is archived as soon as possible. ([View Highlight](https://read.readwise.io/read/01hbns5j747v0esgkq5n1s8axc)) #Highlight #[[2023-10-01]]