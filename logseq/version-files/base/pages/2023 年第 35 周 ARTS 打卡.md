- #ARTS #2023 #Week-35
- # Algorithm - 算法
  collapsed:: true
	- {{embed [[Prim 算法]]}}
- # Review - 英文技术文章阅读与点评
	- #[[Search on Encrypted Data]] [How to Search on Encrypted Data: Functional Encryption (Part 3)](https://esl.cs.brown.edu/blog/how-to-search-on-encrypted-data-functional-encryption-part-3/)
	- FE (functional encryption) Scheme -> IBE (identity based encryption, special case of FE)
	- 标准公钥加密：`c = f(公钥, m)` `m = f(私钥, c)`
	- IBE：`c = f(主公钥, 身份, m)` `m = f(密钥, c), 密钥 = f(主密钥, 身份)`
	- 构建 EDB
		- 创建一对标准公私钥和一对 IBE 主公私钥
		- 服务器存有标准公钥和 IBE 主公钥
		- 文档内容使用标准公钥加密，并将加密后的结果存储至 EDB
		- 构建搜索索引时使用 IBE 主公钥加密，身份为搜索词、密文为 1
			- > 注意需要选用匿名 IBE 算法（标准 IBE 算法会泄漏身份即搜索词）
		- 搜索时，利用 IBE 主私钥和搜索词生成 IBE 密钥，并将 IBE 密钥发送给服务器
		- 服务器利用 IBE 密钥尝试解密所有的密文，解密成功返回
	- 问题
		- 效率：搜索效率 O(mn)
			- > 所以为什么不直接发送 `f(主公钥, 搜索词, 1)` 给服务器将这个利用索引来进行 O(1) 查找呢？
			  > 因为 IBE 算法大都不是（至少 BF-IBE, SK-IBE, BB-IBE 都不是）确定的加密算法（在多次对相同消息进行加密时，即使使用相同的密钥和身份，其生成的密文也会不同），因此无法进行密文索引优化
		- 安全：因为服务器持有公钥，它可以生成搜索词字典进行碰撞（事实上，该问题存在于所有服务器持有公钥的情景中）
			- 解决方案… 对搜索词进行加密来尽可能防止碰撞？
	- 现有 IBE 算法
		- [Boneh–Franklin](https://en.wikipedia.org/wiki/Boneh%E2%80%93Franklin_scheme) (BF-IBE).
		- [Sakai–Kasahara](https://en.wikipedia.org/wiki/Sakai%E2%80%93Kasahara_scheme) (SK-IBE)
		- Boneh–Boyen (BB-IBE)
- # Tip - 本周学到的技术技巧
	- 利用 `document.designMode = true` 可以[开启 Design Mode](https://developer.mozilla.org/en-US/docs/Web/API/Document/designMode) 将整个页面直接变成 Content Editable（也可在 iframe 中在 iframe 的 contentDocument 上生效）
- # Share - 写一篇技术文章
	- [你真的了解 time.Now() 吗？](https://articles.singee.me/golang-time)