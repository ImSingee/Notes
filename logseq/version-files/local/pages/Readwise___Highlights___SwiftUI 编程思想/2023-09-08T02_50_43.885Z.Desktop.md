title:: Readwise/Highlights/SwiftUI 编程思想
author:: [[未知]]
full-title:: SwiftUI 编程思想
category:: #books

- Group 所得到的结果是拥有两个元素的多元组视图，所以边框将会被应⽤到每个视图上去。如果我们想在每个视图上都应⽤同样的修饰器，我们可以利⽤这个技巧 #Highlight #[[2023-07-29]]
- HStack 的初始化⽅法接受⼀个闭包作为参数，这个闭包被标记为了
  @ViewBuilder。这个特性允许我们在闭包⾥书写多个表达式，每个表达式代表⼀个视图。从本质来说，传递给 HStack 的闭包将构建出⼀个视图的列表，这些视图将会成为 HStack 的⼦视图。 #Highlight #[[2023-07-29]]
- SwiftUI 使⽤视图树来构建⼀个持久化 (persistent) 的渲染树。视图树本身是暂态的：我们偏向于把视图树看作是蓝图，它们会被⼀次⼜⼀次地构建，然后⼜被抛弃。⽽另⼀⽅⾯，持久化渲染树上的节点，则拥有更⻓的寿命：它们会在视图渲染的整个期间都存在，并按照当前的状态进⾏更新。 #Highlight #[[2023-07-29]]
- 存在⼀个例外情况，我们也不确定它是不是 SwiftUI 有意为之：当把
  Group (以及它的修饰器) 当作⼀个 ScrollView 的根视图或者唯⼀⼦视图时，Group 的⾏为就会和 VStack 很像，修饰器也不再会应⽤到 Group 中每个单独的视图中去。这条规则还有另外⼀个例外，那就是将 Group 放到 overlay 或者 background ⾥，这时候它表现得会像是⼀个 ZStack。 #Highlight #[[2023-07-29]]
- 显式身份标识并不会覆盖视图原先的隐式身份标识。显式身份只是隐式身份的⼀种“附加说明”。换句话说，SwiftUI 并不会因为在多个视图上使⽤了相同的显式身份标识符⽽把它们弄混 #Highlight #[[2023-07-29]]
- 当像 HStack 这样的容器类视图迭代⼀个视图列表时，嵌套的列表将会通过递归的⽅式进⾏展开，这样以来，⼀棵多元组视图的树将被展平为⼀个视图的列表。这个特性甚⾄在我们打算把 hello 和 bye 的视图构建器属性重构为独⾃的视图时，也依然适⽤ #Highlight #[[2023-07-29]]