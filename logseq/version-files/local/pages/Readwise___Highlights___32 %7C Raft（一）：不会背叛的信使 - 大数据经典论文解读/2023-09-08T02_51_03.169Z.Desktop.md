title:: Readwise/Highlights/32 | Raft（一）：不会背叛的信使 - 大数据经典论文解读
author:: [[徐文浩]]
full-title:: 32 | Raft（一）：不会背叛的信使 - 大数据经典论文解读
category:: #articles
url:: https://time.geekbang.org/column/article/471905

- Leader，本质上是通过一个两阶段提交，来做到同步复制的。一方面，它会先把日志写在本地，同时也发送给 Follower，这个时候，日志还没有提交，也就没有实际生效。Follower 会返回 Leader，是否可以提交日志。当 Leader 接收到超过一半的 Follower 可以提交日志的响应之后，它会再次发送一个提交的请求给到 Follower，完成实际的日志提交，并把写入结果返回给客户端。 #Highlight #[[2023-04-26]]
- 在 Leader 挂掉，切换新 Leader 之后，我们会遇到一个挑战，新的 Leader 可能没有同步到最新的日志写入。而这可能会导致，新的 Leader 会尝试覆盖之前 Leader 已经写入的数据。这个问题就是我们需要解决的第三个问题，也就是“安全性”问题。 #Highlight #[[2023-04-26]]
- 我们只需要确保两点，第一个是系统里始终有 Leader 可用；第二个，是基于 Leader 向其他节点复制数据，始终能确保一致性 #Highlight #[[2023-04-26]]
- 系统里始终有一个 Leader，所有的数据写入，都是发送到 Leader。一方面，Leader 会在本地写入，另一方面，Leader 需要把对应的数据写入复制到其他的服务器上 #Highlight #[[2023-04-26]]
- Raft 算法是有一个强 Leader 的，而 Paxos 算法是无 Leader 或者弱 Leader 的 #Highlight #[[2023-04-26]]
- Raft 算法则把问题拆分成了一个个独立的子问题，比如 Leader 选举（Leader Election）、日志复制（Log Replication）、安全（Safety）和成员变化（Membership Changes） #Highlight #[[2023-04-26]]
- Paxos 算法的出发点，是为了达成分布式共识。状态机复制，只是分布式共识的一个特例，所以如果我们看原始的 Paxos 算法，去理解 Chubby 乃至 ZooKeeper 的实现，会有一个转化过程，不容易理解。 #Highlight #[[2023-04-26]]
- 无论是在 Chubby 还是 Spanner 里，我们通过 Paxos 算法想要解决的问题，其实都是一个“状态机复制（State Machine Replication）”问题，简称 SMR 问题。 #Highlight #[[2023-04-26]]
- 外部的客户端写入数据的时候，都是发送给 Leader。 #Highlight #[[2023-04-26]]
- 除了对比任期之外，Candidate 还需要满足后面我们讨论的一些“安全性”要求，那就是选举出来的 Leader 上，一定要有最新的已经提交的日志 #Highlight #[[2023-04-26]]
- 在一个任期里，一台服务器最多给一个 Candidate 投票，所以投票过程是先到先得，两个服务器都发起了 RequestVote，我们的 Follower 也只能投给一台。 #Highlight #[[2023-04-26]]
- 选举的超时时间在一个区间之内随机化。这样，不同的服务器会在不同的时间点超时，最先超时的那个服务器，大概率会在其他服务器发现超时之前，就赢得投票。 #Highlight #[[2023-04-26]]
- 整个数据写入，就是一个前面我们说的两阶段提交的过程，只不过这个两阶段提交只需要“半数”通过，就可以发起第二阶段的提交操作，而不需要等待所有服务器都确认可以提交。当然，我们可能会遇到某些节点挂掉了，和两阶段提交里一样，我们要做的就是无限重试。 #Highlight #[[2023-04-26]]
- 在发起追加写入日志的复制请求的时候，Leader 的 AppendEntries 的 RPC 里，不仅会有最新的一条日志，还会有上一条日志里的日志索引和任期信息。 #Highlight #[[2023-04-26]]
- 本质上，Raft 的复制操作，是让 Leader 为每一个 Follower 都从 Leader 的尾部往头部循环，找到 Follower 最新同步到哪里的日志。然后从这个位置开始，往后复制 Leader 的日志，直到最新一条的日志。通过这个过程，我们把每一次 Leader 的日志复制，都变成了一次强制所有 Follower 和当前 Leader 日志同步的过程。 #Highlight #[[2023-04-26]]
- 我们不同服务器的日志，可能因为网络延时还没有同步，也可能因为硬件故障还包含未提交的日志 #Highlight #[[2023-04-26]]
- 脏日志，则是来自服务器在担任 Leader 的时候，可能已经在本地写入了日志，然后挂掉了，所以日志没有能够完成提交。 #Highlight #[[2023-04-26]]
- 而我们让 Leader 在追加写入的时候，顺便进行强行同步的过程，给我们带来了一个好处，那就是我们不需要有什么特殊机制，在硬件故障或者两阶段提交失败的时候去做回滚，而是只需要不断强制 Follower 和 Leader 同步，就能保障数据的一致性。 #Highlight #[[2023-04-26]]
- Raft 里，每一个服务器写入的日志，会有两种状态，一种是未提交的，一种是已提交的。我们这里所说的最新，指的是已提交的日志。我们想要确保 Leader 的日志是最新的，只需要在 Leader 选举的时候，让只有最新日志的 Leader 才能被选上就好了。 #Highlight #[[2023-04-26]]
- 在 RequestVote 的请求里，除了预期的下一个任期之外，还要带上 Candidate 已提交的日志的最新的索引和任期信息。
  每一个 Follower，也会比较本地已提交的日志的最新的索引和任期信息。
  如果 Follower 本地有更新的数据，那么它会拒绝投票。 #Highlight #[[2023-04-26]]
- 一旦投票通过，就意味着 Candidate 的已提交的日志，至少和一半的 Follower 一样新或者更新 #Highlight #[[2023-04-26]]