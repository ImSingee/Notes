title:: Readwise/Highlights/33 | Raft（二）：服务器增减的“自举”实现 - 大数据经典论文解读
author:: [[徐文浩]]
full-title:: 33 | Raft（二）：服务器增减的“自举”实现 - 大数据经典论文解读
category:: #articles
url:: https://time.geekbang.org/column/article/472597

- 在整个集群处于 C_{old},C_{new} 这个过渡共识的过程中，整个 Raft 集群会做到以下几点：
  所有的日志追加写入，都会复制到新老配置里所有的服务器上。
  新老配置里的任何一个服务器，都有可能被选举成 Leader 节点。
  无论是选举，还是达成共识后提交日志，投票需要同时满足旧配置里半数以上服务器的通过，而且也需要新配置里半数以上服务器的通过。 #Highlight #[[2023-04-26]]
- 我们并不需要保留这些写入的日志。我们需要保留的，只是日志应用之后的“状态机”就好了，因为 Raft 要解决的不是日志同步问题，而是状态机复制问题。同步并应用日志，只是这个问题的解决方案。 #Highlight #[[2023-04-26]]
- 在 Raft 里，日志压实这个动作，是在每个服务器上各自进行，而不是通过 Leader 进行然后复制到各个 Follower。因为后者会占用太多的网络带宽，完全没有必要。 #Highlight #[[2023-04-26]]
- 如果客户端知道哪一个服务器是 Leader，它就会把对应的请求发给 Leader。如果不知道，它就会随机发送给一个服务器节点，如果那个服务器节点并不是 Leader，它就会拒绝请求同时把它所知道的最新的 Leader 信息返回给到客户端。 #Highlight #[[2023-04-26]]
- 为了避免同一个客户端请求，在 Raft 里被执行两次，每一个客户端请求都需要带上一个类似于 UUID 这样的唯一标识。Raft 自己需要在服务端进行去重，如果对应操作已经执行过了，那只需要返回执行结果，而不需要再次执行。 #Highlight #[[2023-04-26]]
- Raft 算法也需要满足“可线性化”。也就是，已经写入的数据，必须下次读取的时候一定能被读取到 #Highlight #[[2023-04-26]]
- 在 Raft 里，Leader 一样需要一个租约的机制。我们让 Leader 拥有一个固定时长的租约，并且通过和 Follower 的心跳来不断续期。但是，只要在租约时间范围之内，即使 Leader 服务器挂掉了，其他人仍然不能担任 Leader，要到租约过期了，我们新选出的 Leader 才能生效。 #Highlight #[[2023-04-26]]