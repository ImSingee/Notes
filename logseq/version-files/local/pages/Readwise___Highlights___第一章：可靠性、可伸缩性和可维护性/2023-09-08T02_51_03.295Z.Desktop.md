title:: Readwise/Highlights/第一章：可靠性、可伸缩性和可维护性
author:: [[vonng.com]]
full-title:: 第一章：可靠性、可伸缩性和可维护性
category:: #articles
url:: http://ddia.vonng.com/#/ch1

- [DDIA](http://ddia.vonng.com/)
  
  •   [序言](http://ddia.vonng.com#/preface)
  •   [第一部分：数据系统基础](http://ddia.vonng.com#/part-i)
    •   [第一章：可靠性、可伸缩性和可维护性](http://ddia.vonng.com#/ch1)
        •   [关于数据系统的思考](http://ddia.vonng.com#/ch1?id=%e5%85%b3%e4%ba%8e%e6%95%b0%e6%8d%ae%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%80%9d%e8%80%83)
        •   [可靠性](http://ddia.vonng.com#/ch1?id=%e5%8f%af%e9%9d%a0%e6%80%a7)
        
        •   [硬件故障](http://ddia.vonng.com#/ch1?id=%e7%a1%ac%e4%bb%b6%e6%95%85%e9%9a%9c)
        •   [软件错误](http://ddia.vonng.com#/ch1?id=%e8%bd%af%e4%bb%b6%e9%94%99%e8%af%af)
        •   [人为错误](http://ddia.vonng.com#/ch1?id=%e4%ba%ba%e4%b8%ba%e9%94%99%e8%af%af)
        •   [可靠性有多重要？](http://ddia.vonng.com#/ch1?id=%e5%8f%af%e9%9d%a0%e6%80%a7%e6%9c%89%e5%a4%9a%e9%87%8d%e8%a6%81%ef%bc%9f)
        
        •   [可伸缩性](http://ddia.vonng.com#/ch1?id=%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7)
        
        •   [描述负载](http://ddia.vonng.com#/ch1?id=%e6%8f%8f%e8%bf%b0%e8%b4%9f%e8%bd%bd)
        •   [描述性能](http://ddia.vonng.com#/ch1?id=%e6%8f%8f%e8%bf%b0%e6%80%a7%e8%83%bd)
        •   [应对负载的方法](http://ddia.vonng.com#/ch1?id=%e5%ba%94%e5%af%b9%e8%b4%9f%e8%bd%bd%e7%9a%84%e6%96%b9%e6%b3%95)
        
        •   [可维护性](http://ddia.vonng.com#/ch1?id=%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7)
        
        •   [可操作性：人生苦短，关爱运维](http://ddia.vonng.com#/ch1?id=%e5%8f%af%e6%93%8d%e4%bd%9c%e6%80%a7%ef%bc%9a%e4%ba%ba%e7%94%9f%e8%8b%a6%e7%9f%ad%ef%bc%8c%e5%85%b3%e7%88%b1%e8%bf%90%e7%bb%b4)
        •   [简单性：管理复杂度](http://ddia.vonng.com#/ch1?id=%e7%ae%80%e5%8d%95%e6%80%a7%ef%bc%9a%e7%ae%a1%e7%90%86%e5%a4%8d%e6%9d%82%e5%ba%a6)
        •   [可演化性：拥抱变化](http://ddia.vonng.com#/ch1?id=%e5%8f%af%e6%bc%94%e5%8c%96%e6%80%a7%ef%bc%9a%e6%8b%a5%e6%8a%b1%e5%8f%98%e5%8c%96)
        
        •   [本章小结](http://ddia.vonng.com#/ch1?id=%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93)
        •   [参考文献](http://ddia.vonng.com#/ch1?id=%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae)
    •   [第二章：数据模型与查询语言](http://ddia.vonng.com#/ch2)
    •   [第三章：存储与检索](http://ddia.vonng.com#/ch3)
    •   [第四章：编码与演化](http://ddia.vonng.com#/ch4)
  •   [第二部分：分布式数据](http://ddia.vonng.com#/part-ii)
    •   [第五章：复制](http://ddia.vonng.com#/ch5)
    •   [第六章：分区](http://ddia.vonng.com#/ch6)
    •   [第七章：事务](http://ddia.vonng.com#/ch7)
    •   [第八章：分布式系统的麻烦](http://ddia.vonng.com#/ch8)
    •   [第九章：一致性与共识](http://ddia.vonng.com#/ch9)
  •   [第三部分：衍生数据](http://ddia.vonng.com#/part-iii)
    •   [第十章：批处理](http://ddia.vonng.com#/ch10)
    •   [第十一章：流处理](http://ddia.vonng.com#/ch11)
    •   [第十二章：数据系统的未来](http://ddia.vonng.com#/ch12)
  •   [术语表](http://ddia.vonng.com#/glossary)
  •   [后记](http://ddia.vonng.com#/colophon)
  
  [第一章：可靠性、可伸缩性和可维护性](http://ddia.vonng.com#/ch1?id=%e7%ac%ac%e4%b8%80%e7%ab%a0%ef%bc%9a%e5%8f%af%e9%9d%a0%e6%80%a7%e3%80%81%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7%e5%92%8c%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7)
  
  ![](http://ddia.vonng.com/img/ch1.png)
  
  > 互联网做得太棒了，以至于大多数人将它看作像太平洋这样的自然资源，而不是什么人工产物。上一次出现这种大规模且无差错的技术， 你还记得是什么时候吗？
  > 
  > —— [艾伦・凯](http://www.drdobbs.com/architecture-and-design/interview-with-alan-kay/240003442) 在接受 Dobb 博士杂志采访时说（2012 年）
  
  * * *
  
  [TOC]
  
  现今很多应用程序都是 **数据密集型（data-intensive）** 的，而非 **计算密集型（compute-intensive）** 的。因此 CPU 很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。
  
  数据密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应用程序都需要：
  
  •   存储数据，以便自己或其他应用程序之后能再次找到 （*数据库，即 databases*）
  •   记住开销昂贵操作的结果，加快读取速度（*缓存，即 caches (缓存)* ）
  •   允许用户按关键字搜索数据，或以各种方式对数据进行过滤（*搜索索引，即 search indexes*）
  •   向其他进程发送消息，进行异步处理（*流处理，即 stream processing*）
  •   定期处理累积的大批量数据（*批处理，即 batch processing*）
  
  如果这些功能听上去平淡无奇，那是因为这些 **数据系统（data system）** 是非常成功的抽象：我们一直不假思索地使用它们并习以为常。绝大多数工程师不会幻想从零开始编写存储引擎，因为在开发应用时，数据库已经是足够完美的工具了。
  
  但现实没有这么简单。不同的应用有着不同的需求，因而数据库系统也是百花齐放，有着各式各样的特性。实现缓存有很多种手段，创建搜索索引也有好几种方法，诸如此类。因此在开发应用前，我们依然有必要先弄清楚最适合手头工作的工具和方法。而且当单个工具解决不了你的问题时，组合使用这些工具可能还是有些难度的。
  
  本书将是一趟关于数据系统原理、实践与应用的旅程，并讲述了设计数据密集型应用的方法。我们将探索不同工具之间的共性与特性，以及各自的实现原理。
  
  本章将从我们所要实现的基础目标开始：可靠、可伸缩、可维护的数据系统。我们将澄清这些词语的含义，概述考量这些目标的方法。并回顾一些后续章节所需的基础知识。在接下来的章节中我们将抽丝剥茧，研究设计数据密集型应用时可能遇到的设计决策。
  
  [关于数据系统的思考](http://ddia.vonng.com#/ch1?id=%e5%85%b3%e4%ba%8e%e6%95%b0%e6%8d%ae%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%80%9d%e8%80%83)
  
  我们通常认为，数据库、消息队列、缓存等工具分属于几个差异显著的类别。虽然数据库和消息队列表面上有一些相似性 —— 它们都会存储一段时间的数据 —— 但它们有迥然不同的访问模式，这意味着迥异的性能特征和实现手段。
  
  那我们为什么要把这些东西放在 **数据系统（data system）** 的总称之下混为一谈呢？
  
  近些年来，出现了许多新的数据存储工具与数据处理工具。它们针对不同应用场景进行优化，因此不再适合生硬地归入传统类别【1】。类别之间的界限变得越来越模糊，例如：数据存储可以被当成消息队列用（Redis），消息队列则带有类似数据库的持久保证（Apache Kafka）。
  
  其次，越来越多的应用程序有着各种严格而广泛的要求，单个工具不足以满足所有的数据处理和存储需求。取而代之的是，总体工作被拆分成一系列能被单个工具高效完成的任务，并通过应用代码将它们缝合起来。
  
  例如，如果将缓存（应用管理的缓存层，Memcached 或同类产品）和全文搜索（全文搜索服务器，例如 Elasticsearch 或 Solr）功能从主数据库剥离出来，那么使缓存 / 索引与主数据库保持同步通常是应用代码的责任。[图 1-1](http://ddia.vonng.com#/img/fig1-1.png) 给出了这种架构可能的样子（细节将在后面的章节中详细介绍）。
  
  ![](http://ddia.vonng.com/img/fig1-1.png)
  
  **图 1-1 一个可能的组合使用多个组件的数据系统架构**
  
  当你将多个工具组合在一起提供服务时，服务的接口或 **应用程序编程接口（API, Application Programming Interface）** 通常向客户端隐藏这些实现细节。现在，你基本上已经使用较小的通用组件创建了一个全新的、专用的数据系统。这个新的复合数据系统可能会提供特定的保证，例如：缓存在写入时会作废或更新，以便外部客户端获取一致的结果。现在你不仅是应用程序开发人员，还是数据系统设计人员了。
  
  设计数据系统或服务时可能会遇到很多棘手的问题，例如：当系统出问题时，如何确保数据的正确性和完整性？当部分系统退化降级时，如何为客户提供始终如一的良好性能？当负载增加时，如何扩容应对？什么样的 API 才是好的 API？
  
  影响数据系统设计的因素很多，包括参与人员的技能和经验、历史遗留问题、系统路径依赖、交付时限、公司的风险容忍度、监管约束等，这些因素都需要具体问题具体分析。
  
  本书着重讨论三个在大多数软件系统中都很重要的问题：
  
  •   可靠性（Reliability）
    
    系统在 **困境**（ adversity (逆境) ，比如硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。请参阅 “[可靠性](http://ddia.vonng.com#/ch1?id=%e5%8f%af%e9%9d%a0%e6%80%a7)”。
    
  •   可伸缩性（ Scalability (可伸缩性) ）
    
    有合理的办法应对系统的增长（数据量、流量、复杂性）。请参阅 “[可伸缩性](http://ddia.vonng.com#/ch1?id=%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7)”。
    
  •   可维护性（Maintainability）
    
    许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。请参阅 “[可维护性](http://ddia.vonng.com#/ch1?id=%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7)”。
    
  
  人们经常追求这些词汇，却没有清楚理解它们到底意味着什么。为了工程的严谨性，本章的剩余部分将探讨可靠性、可伸缩性和可维护性的含义。为实现这些目标而使用的各种技术，架构和算法将在后续的章节中研究。
  
  [可靠性](http://ddia.vonng.com#/ch1?id=%e5%8f%af%e9%9d%a0%e6%80%a7)
  
  人们对于一个东西是否可靠，都有一个直观的想法。人们对可靠软件的典型期望包括：
  
  •   应用程序表现出用户所期望的功能。
  •   允许用户犯错，允许用户以出乎意料的方式使用软件。
  •   在预期的负载和数据量下，性能满足要求。
  •   系统能防止未经授权的访问和滥用。
  
  如果所有这些在一起意味着 “正确工作”，那么可以把可靠性粗略理解为 “即使出现问题，也能继续正确工作”。
  
  造成错误的原因叫做 **故障（fault）**，能预料并应对故障的系统特性可称为 **容错（fault-tolerant）** 或 **韧性（ resilient (弹性) ）**。“**容错**” 一词可能会产生误导，因为它暗示着系统可以容忍所有可能的错误，但在实际中这是不可能的。比方说，如果整个地球（及其上的所有服务器）都被黑洞吞噬了，想要容忍这种错误，需要把网络托管到太空中 —— 这种预算能不能批准就祝你好运了。所以在讨论容错时，只有谈论特定类型的错误才有意义。
  
  注意 **故障（fault）** 不同于 **失效（failure）**【2】。**故障** 通常定义为系统的一部分状态偏离其标准，而 **失效** 则是系统作为一个整体停止向用户提供服务。故障的概率不可能降到零，因此最好设计容错机制以防因 **故障** 而导致 **失效**。本书中我们将介绍几种用不可靠的部件构建可靠系统的技术。
  
  反直觉的是，在这类容错系统中，通过故意触发来 **提高** 故障率是有意义的，例如：在没有警告的情况下随机地杀死单个进程。许多高危漏洞实际上是由糟糕的错误处理导致的【3】，因此我们可以通过故意引发故障来确保容错机制不断运行并接受考验，从而提高故障自然发生时系统能正确处理的信心。Netflix 公司的 *Chaos Monkey*【4】就是这种方法的一个例子。
  
  尽管比起 **阻止错误（prevent error）**，我们通常更倾向于 **容忍错误**。但也有 **预防胜于治疗** 的情况（比如不存在治疗方法时）。安全问题就属于这种情况。例如，如果攻击者破坏了系统，并获取了敏感数据，这种事是撤销不了的。但本书主要讨论的是可以恢复的故障种类，正如下面几节所述。
  
  [硬件故障](http://ddia.vonng.com#/ch1?id=%e7%a1%ac%e4%bb%b6%e6%95%85%e9%9a%9c)
  
  当想到系统失效的原因时，**硬件故障（hardware faults）** 总会第一个进入脑海。硬盘崩溃、内存出错、机房断电、有人拔错网线…… 任何与大型数据中心打过交道的人都会告诉你：一旦你拥有很多机器，这些事情 **总** 会发生！
  
  据报道称，硬盘的 **平均无故障时间（MTTF, mean time to failure）** 约为 10 到 50 年【5】【6】。因此从数学期望上讲，在拥有 10000 个磁盘的存储集群上，平均每天会有 1 个磁盘出故障。
  
  为了减少系统的故障率，第一反应通常都是增加单个硬件的冗余度，例如：磁盘可以组建 RAID，服务器可能有双路电源和热插拔 CPU，数据中心可能有电池和柴油发电机作为后备电源，某个组件挂掉时冗余组件可以立刻接管。这种方法虽然不能完全防止由硬件问题导致的系统失效，但它简单易懂，通常也足以让机器不间断运行很多年。
  
  直到最近，硬件冗余对于大多数应用来说已经足够了，它使单台机器完全失效变得相当罕见。只要你能快速地把备份恢复到新机器上，故障停机时间对大多数应用而言都算不上灾难性的。只有少量高可用性至关重要的应用才会要求有多套硬件冗余。
  
  但是随着数据量和应用计算需求的增加，越来越多的应用开始大量使用机器，这会相应地增加硬件故障率。此外，在类似亚马逊 AWS（Amazon Web Services）的一些云服务平台上，虚拟机实例不可用却没有任何警告也是很常见的【7】，因为云平台的设计就是优先考虑 **灵活性（flexibility）** 和 **弹性（ elasticity ）**[^i]，而不是单机可靠性。
  
  如果在硬件冗余的基础上进一步引入软件容错机制，那么系统在容忍整个（单台）机器故障的道路上就更进一步了。这样的系统也有运维上的便利，例如：如果需要重启机器（例如应用操作系统安全补丁），单服务器系统就需要计划停机。而允许机器失效的系统则可以一次修复一个节点，无需整个系统停机。
  
  [^i]: 在 [应对负载的方法](http://ddia.vonng.com#/ch1?id=%e5%ba%94%e5%af%b9%e8%b4%9f%e8%bd%bd%e7%9a%84%e6%96%b9%e6%b3%95) 一节定义
  
  [软件错误](http://ddia.vonng.com#/ch1?id=%e8%bd%af%e4%bb%b6%e9%94%99%e8%af%af)
  
  我们通常认为硬件故障是随机的、相互独立的：一台机器的磁盘失效并不意味着另一台机器的磁盘也会失效。虽然大量硬件组件之间可能存在微弱的相关性（例如服务器机架的温度等共同的原因），但同时发生故障也是极为罕见的。
  
  另一类错误是内部的 **系统性错误（systematic error）**【8】。这类错误难以预料，而且因为是跨节点相关的，所以比起不相关的硬件故障往往可能造成更多的 **系统失效**【5】。例子包括：
  
  •   接受特定的错误输入，便导致所有应用服务器实例崩溃的 BUG。例如 2012 年 6 月 30 日的闰秒，由于 Linux 内核中的一个错误【9】，许多应用同时挂掉了。
  •   失控进程会 ([View Highlight](https://read.readwise.io/read/01g9eaffmw9p3dm8mq18jjwwvf)) #Highlight #[[2022-08-02]]
- 近些年来，出现了许多新的数据存储工具与数据处理工具。它们针对不同应用场景进行优化，因此不再适合生硬地归入传统类别【1】。类别之间的界限变得越来越模糊，例如：数据存储可以被当成消息队列用（Redis），消息队列则带有类似数据库的持久保证（Apache Kafka）。 ([View Highlight](https://read.readwise.io/read/01g9e9e8yztv1x3nyq91vg8zm0)) #Highlight #[[2022-08-02]]
- 因为写请求在不同的时间到达不同的节点。无论数据库使用何种复制方法（单主复制，多主复制或无主复制），都会出现这些不一致情况。 ([View Highlight](https://read.readwise.io/read/01gb9tk2t7hnmz4770096rm93h)) #Highlight #[[2022-08-25]]
- 大多数复制的数据库至少提供了 **最终一致性**，这意味着如果你停止向数据库写入数据并等待一段不确定的时间，那么最终所有的读取请求都会返回相同的值【1】。换句话说，不一致性是暂时的，最终会自行解决（假设网络中的任何故障最终都会被修复）。最终一致性的一个更好的名字可能是 **收敛（convergence）**，因为我们预计所有的副本最终会收敛到相同的值【2】。 ([View Highlight](https://read.readwise.io/read/01gb9tk5z4rbzpsvqar8vbnx74)) #Highlight #[[2022-08-25]]
- 在收敛之前，读操作可能会返回任何东西或什么都没有【1】。例如，如果你写入了一个值，然后立即再次读取，这并不能保证你能看到刚才写入的值，因为读请求可能会被路由到另外的副本上。 ([View Highlight](https://read.readwise.io/read/01gb9tkgw2xetqvwyjwk6mxq0q)) #Highlight #[[2022-08-25]]
- 事务所提供的安全保证，通常由众所周知的首字母缩略词 ACID 来描述，ACID 代表 **原子性（Atomicity）**，**一致性（Consistency）**，**隔离性（Isolation）** 和 **持久性（Durability）**。它由 Theo Härder 和 Andreas Reuter 于 1983 年提出，旨在为数据库中的容错机制建立精确的术语。 ([View Highlight](https://read.readwise.io/read/01gb9tbaa2jjbwnknj02japf7m)) #Highlight #[[2022-08-25]]
- 不符合 ACID 标准的系统有时被称为 BASE，它代表 **基本可用性（Basically Available）**，**软状态（Soft State）** 和 **最终一致性（Eventual consistency）**【9】，这比 ACID 的定义更加模糊，似乎 BASE 的唯一合理的定义是 “不是 ACID”，即它几乎可以代表任何你想要的东西。 ([View Highlight](https://read.readwise.io/read/01gb9tbygy84rqgphcearw9xbj)) #Highlight #[[2022-08-25]]
- 在 **最终一致** 的数据库，如果你在同一时刻问两个不同副本相同的问题，可能会得到两个不同的答案。这很让人困惑。如果数据库可以提供只有一个副本的假象（即，只有一个数据副本），那么事情就简单太多了。那么每个客户端都会有相同的数据视图，且不必担心复制滞后了。 ([View Highlight](https://read.readwise.io/read/01gb9tn8vgehnr9hp87z4xq15t)) #Highlight #[[2022-08-25]]
- ACID 的原子性并 **不** 是关于 **并发（concurrent）** 的。它并不是在描述如果几个进程试图同时访问相同的数据会发生什么情况，这种情况包含在缩写 ***I*** 中，即 [**隔离性**](http://ddia.vonng.com#/ch7?id=%e9%9a%94%e7%a6%bb%e6%80%a7)。 ([View Highlight](https://read.readwise.io/read/01gb9tcsp93q0ma157regcj43a)) #Highlight #[[2022-08-25]]
- **线性一致性（linearizability）** 背后的想法【6】（也称为 **原子一致性（atomic consistency）**【7】，**强一致性（strong consistency）**，**立即一致性（immediate consistency）** 或 **外部一致性（external consistency ）**【8】）。线性一致性的精确定义相当微妙，我们将在本节的剩余部分探讨它。但是基本的想法是让一个系统看起来好像只有一个数据副本，而且所有的操作都是原子性的。有了这个保证，即使实际中可能有多个副本，应用也不需要担心它们。 ([View Highlight](https://read.readwise.io/read/01gb9tnvytfrcxkzhn957d4yn0)) #Highlight #[[2022-08-25]]
- 人们对于一个东西是否可靠，都有一个直观的想法。人们对可靠软件的典型期望包括：
  
  •   应用程序表现出用户所期望的功能。
  •   允许用户犯错，允许用户以出乎意料的方式使用软件。
  •   在预期的负载和数据量下，性能满足要求。
  •   系统能防止未经授权的访问和滥用。
  
  如果所有这些在一起意味着 “正确工作”，那么可以把可靠性粗略理解为 “即使出现问题，也能继续正确工作”。 ([View Highlight](https://read.readwise.io/read/01g9e9e8yztv1x3nyq91vg8zm0)) #Highlight #[[2022-08-02]]
- 在一个线性一致的系统中，只要一个客户端成功完成写操作，所有客户端从数据库中读取数据必须能够看到刚刚写入的值 ([View Highlight](https://read.readwise.io/read/01gb9tpdg9pkarg9mze01hphjh)) #Highlight #[[2022-08-25]]
- ACID 原子性的定义特征是：**能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力。** 或许 **可中止性（abortability）** 是更好的术语 ([View Highlight](https://read.readwise.io/read/01gb9td6449bpx3htne2an0jte)) #Highlight #[[2022-08-25]]
- 原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID ([View Highlight](https://read.readwise.io/read/01gb9tewt2xyeqxe2q0ccb7dkv)) #Highlight #[[2022-08-25]]
- 一致性哈希由 Karger 等人定义。【7】 用于跨互联网级别的缓存系统，例如 CDN 中，是一种能均匀分配负载的方法。它使用随机选择的 **分区边界（partition boundaries）** 来避免中央控制或分布式共识的需要。 请注意，这里的一致性与复制一致性（请参阅 [第五章](http://ddia.vonng.com#/ch5)）或 ACID 一致性（请参阅 [第七章](http://ddia.vonng.com#/ch7)）无关，而只是描述了一种重新平衡（reblancing）的特定方法。 ([View Highlight](https://read.readwise.io/read/01gb9th76v89a2qhhsj4e13jn9)) #Highlight #[[2022-08-25]]
- 因为有可能产生混淆，所以最好避免使用一致性哈希这个术语，而只是把它称为 **散列分区（hash partitioning）**。 ([View Highlight](https://read.readwise.io/read/01gb9thbpprwxf98be9gs4d03r)) #Highlight #[[2022-08-25]]